// apps/api/src/modules/ranking/ranking.service.ts (VERSÃO REALMENTE COMPLETA E CORRIGIDA)
import { AppDataSource } from '@/database/data-source';
import { CriterionEntity } from '@/entity/criterion.entity';
import { ParameterValueEntity } from '@/entity/parameter-value.entity';
import { PerformanceDataEntity } from '@/entity/performance-data.entity';
import { SectorEntity } from '@/entity/sector.entity';
import {
  EntradaRanking,
  EntradaResultadoDetalhado,
} from '@sistema-premiacao/shared-types';
import {
  FindOptionsWhere,
  IsNull,
  LessThanOrEqual,
  MoreThanOrEqual,
} from 'typeorm';

// Interface auxiliar interna - NOMES EM PORTUGUÊS
interface ResultadoPorCriterio {
  setorId: number;
  setorNome: string;
  criterioId: number;
  criterioNome: string;
  valorRealizado: number | null;
  valorMeta: number | null;
  razaoCalculada: number | null; // Pode ser null, finite, Infinity, -Infinity
  rank?: number;
  pontos: number | null;
}
interface AcumuladorScoreSetor {
  nome: string;
  totalScore: number;
}

export class RankingService {
  private sectorRepo = AppDataSource.getRepository(SectorEntity);
  private criterionRepo = AppDataSource.getRepository(CriterionEntity);
  private parameterRepo = AppDataSource.getRepository(ParameterValueEntity);
  private performanceRepo = AppDataSource.getRepository(PerformanceDataEntity);

  // --- MÉTODO PRIVADO: Lógica Central de Cálculo ---
  private async calculateAllResults(period?: string): Promise<{
    ranking: EntradaRanking[];
    details: EntradaResultadoDetalhado[];
  }> {
    console.log(
      `[RankingService] Iniciando cálculo base para o período: ${period || 'Último disponível'}`
    );
    const targetDate = '2025-05-01'; // MVP Fixo

    // 1. Buscar Dados Base
    const activeSectors = await this.sectorRepo.findBy({ ativo: true });
    const activeCriteria = await this.criterionRepo.findBy({ ativo: true });
    if (!activeSectors.length || !activeCriteria.length) {
      return { ranking: [], details: [] };
    }
    console.log(
      `[RankingService] Setores: ${activeSectors.length}, Critérios: ${activeCriteria.length}`
    );

    // 2. Buscar Dados do Período
    const performanceData = await this.performanceRepo.find({
      where: { metricDate: targetDate },
    });
    const whereParams: FindOptionsWhere<ParameterValueEntity> = {
      dataInicioEfetivo: LessThanOrEqual(targetDate),
      dataFimEfetivo: IsNull(),
    };
    const whereParamsExpired: FindOptionsWhere<ParameterValueEntity> = {
      dataInicioEfetivo: LessThanOrEqual(targetDate),
      dataFimEfetivo: MoreThanOrEqual(targetDate),
    };
    const currentParameters = await this.parameterRepo.find({
      where: [whereParams, whereParamsExpired],
    });
    console.log(
      `[RankingService] Desempenho: ${performanceData.length}, Parâmetros: ${currentParameters.length}`
    );

    // 3. Preparar Acumuladores
    const sectorScores: { [id: number]: AcumuladorScoreSetor } = {};
    activeSectors.forEach((s) => {
      sectorScores[s.id] = { nome: s.nome, totalScore: 0 };
    });
    const allDetailedResults: EntradaResultadoDetalhado[] = [];

    // 4. Calcular por Critério
    for (const criterion of activeCriteria) {
      const resultsForCriterion: ResultadoPorCriterio[] = [];

      performanceData
        .filter((p) => p.criterionId === criterion.id)
        .forEach((p) => {
          console.log(
            ` - setorId: ${p.sectorId}, criterioId: ${p.criterionId}, valor: ${p.valor}`
          );
        });
      for (const sector of activeSectors) {
        const perf = performanceData.find(
          (p) => p.sectorId === sector.id && p.criterionId === criterion.id
        );

        const valorRealizado =
          perf?.valor != null ? parseFloat(String(perf.valor)) : null;

        //  Buscar a meta, com fallback para meta genérica (sem setor)
        let targetParam = currentParameters.find(
          (p) =>
            p.criterionId === criterion.id &&
            p.sectorId === sector.id &&
            p.nomeParametro.startsWith('META_')
        );
        if (!targetParam) {
          targetParam = currentParameters.find(
            (p) =>
              p.criterionId === criterion.id &&
              !p.sectorId &&
              p.nomeParametro.startsWith('META_')
          );
        }

        const valorMeta =
          targetParam?.valor != null
            ? parseFloat(String(targetParam.valor))
            : null;

        // Cálculo da razão
        let razaoCalculada: number | null = null;
        if (valorRealizado === 0 && valorMeta === 0) {
          razaoCalculada = 1; // Caso especial: meta 0 e realizado 0 = OK
        } else if (
          valorRealizado != null &&
          valorMeta != null &&
          valorMeta !== 0
        ) {
          razaoCalculada = valorRealizado / valorMeta;
          console.log(`PErcentual: ${razaoCalculada}`);
        } else if (valorRealizado != null && valorMeta === 0) {
          razaoCalculada =
            criterion.sentido_melhor === 'MAIOR' ? Infinity : -Infinity;
        } else {
          razaoCalculada = null;
        }

        resultsForCriterion.push({
          setorId: sector.id,
          setorNome: sector.nome,
          criterioId: criterion.id,
          criterioNome: criterion.nome,
          valorRealizado,
          valorMeta,
          razaoCalculada,
          pontos: null,
        });
      }
      //LOG FALTA FROTA

      // Ordenação
      resultsForCriterion.sort((a, b) => {
        console.log(`PErcentual A na ordenação: ${a.razaoCalculada}`);
        console.log(`PErcentual b na ordenação: ${b.razaoCalculada}`);

        const valA = a.razaoCalculada;
        const valB = b.razaoCalculada;

        if (valA === null && valB === null) return 0;
        if (valA === null) return 1;
        if (valB === null) return -1;

        const isAInf = !isFinite(valA);
        const isBInf = !isFinite(valB);

        if (isAInf && isBInf) {
          return valA === valB
            ? 0
            : criterion.sentido_melhor === 'MAIOR'
              ? valA === Infinity
                ? -1
                : 1
              : valA === -Infinity
                ? -1
                : 1;
        }
        if (isAInf) {
          return valA === Infinity
            ? criterion.sentido_melhor === 'MAIOR'
              ? -1
              : 1
            : criterion.sentido_melhor === 'MENOR'
              ? -1
              : 1;
        }
        if (isBInf) {
          return valB === Infinity
            ? criterion.sentido_melhor === 'MAIOR'
              ? 1
              : -1
            : criterion.sentido_melhor === 'MENOR'
              ? 1
              : -1;
        }

        return criterion.sentido_melhor === 'MAIOR' ? valB - valA : valA - valB;
      });

      // 4.2a Atribuir Rank considerando empates na razaoCalculada
      let currentRank = 0;
      let lastRazao: number | null | undefined = undefined; // Para comparar com a razaoCalculada anterior
      let tieCount = 0; // Para ajustar o próximo rank após um empate

      resultsForCriterion.forEach((result, index) => {
        console.log(`PErcentual resultsForCriterion: ${result.razaoCalculada}`);
        if (
          result.razaoCalculada === null ||
          result.razaoCalculada === undefined
        ) {
          result.rank = undefined; // Ou um rank de "não classificado", ex: 5 ou null
        } else {
          if (result.razaoCalculada !== lastRazao) {
            currentRank = index + 1 - tieCount; // Ajusta o rank se houve empates anteriores
            tieCount = 0; // Reseta contador de empates
          } else {
            tieCount++; // Incrementa contador de empates
          }
          result.rank = currentRank;
          lastRazao = result.razaoCalculada;
        }
      });

      const useInvertedScale = criterion.index === 0;
      resultsForCriterion.forEach((result) => {
        let pontos: number | null = null;

        if (criterion.id === 5) {
          // Regra especial para critério FALTA FUNC
          if (result.valorRealizado !== null && result.valorRealizado <= 10) {
            pontos = 1;
          } else {
            // Aplica a regra normal só se valorRealizado > 10
            switch (result.rank) {
              case 1:
                pontos = 1.0;
                break;
              case 2:
                pontos = 1.5;
                break;
              case 3:
                pontos = 2.0;
                break;
              case 4:
                pontos = 2.5;
                break;
              default:
                pontos = null;
            }
          }
        } else {
          const todosMesmaRazao = resultsForCriterion.every(
            (r) => r.razaoCalculada === 1
          );
          console.log(`PErcentual todosMesmaRazao: ${todosMesmaRazao}`);

          if (todosMesmaRazao) {
            pontos = 1.0; // Pontuação padrão (verde)
          } else {
            switch (result.rank) {
              case 1:
                pontos = useInvertedScale ? 2.5 : 1.0;
                break;
              case 2:
                pontos = useInvertedScale ? 2.0 : 1.5;
                break;
              case 3:
                pontos = useInvertedScale ? 1.5 : 2.0;
                break;
              case 4:
                pontos = useInvertedScale ? 1.0 : 2.5;
                break;
              default:
                pontos = null;
            }
          }
        }
        result.pontos = pontos;

        const currentSectorScore = sectorScores[result.setorId];
        if (currentSectorScore && pontos !== null) {
          currentSectorScore.totalScore += pontos;
          console.log(
            `PErcentual  percentualAtingimento: ${result.razaoCalculada}`
          );

          allDetailedResults.push({
            setorId: result.setorId,
            setorNome: result.setorNome,
            criterioId: result.criterioId,
            criterioNome: result.criterioNome,
            periodo: targetDate.substring(0, 7),
            valorRealizado: result.valorRealizado,
            valorMeta: result.valorMeta,
            percentualAtingimento: result.razaoCalculada,

            pontos: result.pontos,
          });
        } else if (!currentSectorScore) {
          console.error(
            `[RankingService] Score não encontrado para setor ID ${result.setorId}`
          );
        }
      });
    } // ----- FIM CÁLCULO POR CRITÉRIO -----

    // 5. Calcular Ranking Final
    console.log('[RankingService] Calculando ranking final...');
    console.log(
      '[RankingService] Scores FINAIS antes de ranquear:',
      JSON.stringify(sectorScores)
    );
    const finalRankingArray = Object.values(sectorScores)
      .sort((a, b) => a.totalScore - b.totalScore)
      .map((score, index) => ({
        RANK: index + 1,
        SETOR: score.nome,
        PONTUACAO: parseFloat(score.totalScore.toFixed(2)),
      }));
    console.log('[RankingService] Ranking final calculado:', finalRankingArray);
    return { ranking: finalRankingArray, details: allDetailedResults };
  } // Fim calculateAllResults

  // --- MÉTODOS PÚBLICOS ---
  async getCurrentRanking(period?: string): Promise<EntradaRanking[]> {
    console.log(
      `[RankingService] GET CURRENT RANKING para período: ${period || 'Default'}`
    );
    try {
      const { ranking } = await this.calculateAllResults(period);
      return ranking;
    } catch (error) {
      console.error('[RankingService] Erro em getCurrentRanking:', error);
      throw new Error('Falha ao calcular ranking.');
    }
  }

  async getDetailedResults(
    period?: string
  ): Promise<EntradaResultadoDetalhado[]> {
    console.log(
      `[RankingService] GET DETAILED RESULTS para período: ${period || 'Default'}`
    );
    try {
      const { details } = await this.calculateAllResults(period);
      return details;
    } catch (error) {
      console.error('[RankingService] Erro em getDetailedResults:', error);
      throw new Error('Falha ao buscar resultados detalhados.');
    }
  }
} // Fim Classe
