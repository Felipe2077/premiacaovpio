import { AppDataSource } from '@/database/data-source';
import cors from '@fastify/cors';
import * as dotenv from 'dotenv';
import Fastify from 'fastify';
// Importa todos os servi√ßos
import { CompetitionPeriodEntity } from '@/entity/competition-period.entity';
import { CriterionEntity } from '@/entity/criterion.entity';
import { AuditLogService } from '@/modules/audit/audit.service';
import { ExpurgoService } from '@/modules/expurgos/expurgo.service';
import { HistoryService } from '@/modules/historical/history.service';
import { ParameterService } from '@/modules/parameters/parameter.service';
import { CompetitionPeriodService } from '@/modules/periods/period.service';
import { RankingService } from '@/modules/ranking/ranking.service';
import multipart from '@fastify/multipart';
import {
  ApproveExpurgoDto,
  CalculateParameterDto,
  CreateParameterDto,
  RejectExpurgoDto,
  UpdateParameterDto,
} from '@sistema-premiacao/shared-types';
import * as fs from 'fs';
import { SectorEntity } from './entity/sector.entity';
import { CriterionCalculationSettingsService } from './modules/parameters/criterion-calculation-settings.service';
import { registerHistoricalResultsRoutes } from './routes/historical-results.routes';

// === IMPORTS DE AUTENTICA√á√ÉO ===
import {
  adminOnly,
  approveExpurgos,
  auditAdminAction,
  closePeriods,
  manageParameters,
  manageUsers,
  requirePermissions,
  requireRoles,
  requireSectorAccess,
  startPeriods,
  viewReports,
} from './middleware/rbac.middleware';
import authPlugin from './plugins/auth.plugin';
import { authRoutes } from './routes/auth.routes';
import { AuthService } from './services/auth.service';

dotenv.config();

const fastify = Fastify({
  logger: {
    level: process.env.LOG_LEVEL || 'info',
    transport:
      process.env.NODE_ENV === 'development'
        ? {
            target: 'pino-pretty',
            options: {
              colorize: true,
              translateTime: 'HH:MM:ss Z',
              ignore: 'pid,hostname',
            },
          }
        : undefined,
  },
});

// --- Instanciar TODOS os Servi√ßos ---
const rankingService = new RankingService();
const parameterService = new ParameterService();
const auditLogService = new AuditLogService();
const expurgoService = new ExpurgoService();
const competitionPeriodService = new CompetitionPeriodService();
const periodRepository = AppDataSource.getRepository(CompetitionPeriodEntity);
const historyService = new HistoryService();
const authService = new AuthService();

// Fun√ß√£o start async
const start = async () => {
  try {
    console.log('üöÄ Iniciando servidor com autentica√ß√£o integrada...');

    // === 1. REGISTRAR CORS ===
    await fastify.register(cors, {
      origin:
        process.env.NODE_ENV === 'development'
          ? [
              'http://localhost:3000',
              'http://127.0.0.1:3000',
              /http:\/\/192\.168\.\d+\.\d+:3000/,
            ]
          : process.env.ALLOWED_ORIGINS?.split(',') || false,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
      credentials: true,
    });
    fastify.log.info('‚úÖ Plugin CORS registrado.');

    // === 2. REGISTRAR MULTIPART ===
    await fastify.register(multipart, {
      limits: {
        fileSize: 10 * 1024 * 1024, // 10MB
      },
    });

    // === 3. REGISTRAR PLUGIN DE AUTENTICA√á√ÉO ===
    await fastify.register(authPlugin);
    fastify.log.info('‚úÖ Plugin de autentica√ß√£o registrado.');

    // === 4. REGISTRAR ROTAS DE AUTENTICA√á√ÉO ===
    await fastify.register(authRoutes);
    fastify.log.info('‚úÖ Rotas de autentica√ß√£o registradas.');

    // === 5. INICIALIZAR BANCO DE DADOS ===
    if (!AppDataSource.isInitialized) {
      await AppDataSource.initialize();
      fastify.log.info('Data Source Postgres inicializado pelo servidor.');
      console.log(
        '<== AppDataSource.initialize() CONCLU√çDO (sem erro lan√ßado).'
      );

      try {
        console.log('==> Verificando tabelas existentes via TypeORM...');
        const queryRunner = AppDataSource.createQueryRunner();
        const tableNames = [
          'sectors',
          'criteria',
          'roles',
          'users',
          'user_roles',
          'parameter_values',
          'performance_data',
          'audit_logs',
          'expurgo_events',
          'competition_periods',
          'user_sessions',
        ];
        const tables = await queryRunner.getTables(tableNames);
        await queryRunner.release();

        if (tables.length > 0) {
          console.log(
            `<== TypeORM encontrou ${tables.length} tabelas:`,
            tables.map((t) => t.name)
          );
        } else {
          console.warn(
            "<== TypeORM N√ÉO encontrou NENHUMA das tabelas esperadas no schema 'public'. Sincroniza√ß√£o n√£o ocorreu?"
          );
        }
      } catch (getTableError) {
        console.error(
          '<== ERRO ao tentar verificar tabelas via TypeORM:',
          getTableError
        );
      }

      // --- Tentar Sincroniza√ß√£o Expl√≠cita ---
      try {
        console.log('==> Tentando sincroniza√ß√£o expl√≠cita do schema...');
        await AppDataSource.synchronize();
        console.log('<== Sincroniza√ß√£o expl√≠cita CONCLU√çDA.');
      } catch (syncErr) {
        console.error('<== ERRO durante sincroniza√ß√£o EXPL√çCITA:', syncErr);
      }
    } else {
      console.log('AppDataSource j√° estava inicializado.');
      try {
        console.log(
          '==> Tentando sincroniza√ß√£o expl√≠cita do schema (AppDataSource j√° init)...'
        );
        await AppDataSource.synchronize();
        console.log('<== Sincroniza√ß√£o expl√≠cita conclu√≠da.');
      } catch (syncErr) {
        console.error(
          '<== ERRO durante sincroniza√ß√£o EXPL√çCITA (DS j√° init):',
          syncErr
        );
      }
    }

    // === 6. ROTAS DE SA√öDE (P√öBLICAS) ===
    fastify.get('/health', async (request, reply) => {
      const health = await authService.healthCheck();

      return {
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        auth: health,
        version: process.env.npm_package_version || '1.0.0',
      };
    });

    fastify.get(
      '/api/health',
      {
        preHandler: [fastify.authenticate],
      },
      async (request, reply) => {
        const health = await authService.healthCheck();

        return {
          status: 'authenticated',
          user: request.user,
          auth: health,
          timestamp: new Date().toISOString(),
        };
      }
    );

    // === 7. ROTAS DE RANKING E RESULTADOS (PROTEGIDAS) ===
    fastify.get(
      '/api/ranking',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        try {
          const data = await rankingService.getCurrentRanking();
          reply.send(data);
        } catch (error: any) {
          fastify.log.error(`Erro em /api/ranking: ${error.message}`);
          reply.status(500).send({ error: error.message || 'Erro.' });
        }
      }
    );

    fastify.get(
      '/api/results/by-date',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        try {
          const query = request.query as {
            period?: string;
            targetDate?: string;
          };
          const { period, targetDate } = query;

          console.log(
            `[API] GET /api/results/by-date - Per√≠odo: ${period || 'n√£o especificado'}, Data alvo: ${targetDate || 'n√£o especificada'}`
          );

          const data = await rankingService.getDetailedResultsByDate(
            period,
            targetDate
          );

          console.log(
            `[API] GET /api/results/by-date - Resultados encontrados: ${data.length}`
          );
          reply.send(data);
        } catch (error: any) {
          console.error(
            `[API] ERRO em /api/results/by-date: ${error.message}`,
            error
          );
          reply.status(500).send({ error: error.message || 'Erro.' });
        }
      }
    );

    fastify.get(
      '/api/results',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        try {
          const query = request.query as { period?: string };
          const period = query.period;

          console.log(
            `[API] GET /api/results - Per√≠odo solicitado: ${period || 'n√£o especificado'}`
          );

          const data = await rankingService.getDetailedResults(period);

          console.log(
            `[API] GET /api/results - Resultados encontrados: ${data.length}`
          );
          reply.send(data);
        } catch (error: any) {
          console.error(`[API] ERRO em /api/results: ${error.message}`, error);
          reply.status(500).send({ error: error.message || 'Erro.' });
        }
      }
    );

    fastify.get(
      '/api/results/current',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        try {
          const activePeriod = await periodRepository.findOne({
            where: { status: 'ATIVA' },
          });

          if (!activePeriod) {
            reply
              .status(404)
              .send({ error: 'Nenhuma vig√™ncia ATIVA encontrada' });
            return;
          }

          fastify.log.info(
            `Buscando resultados para vig√™ncia ATIVA: ${activePeriod.mesAno}`
          );

          const data = await rankingService.getDetailedResults(
            activePeriod.mesAno
          );
          reply.send(data);
        } catch (error: any) {
          fastify.log.error(`Erro em /api/results/current: ${error.message}`);
          reply.status(500).send({ error: error.message || 'Erro.' });
        }
      }
    );

    fastify.get(
      '/api/results/by-period',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        try {
          const query = request.query as { period?: string };
          const { period } = query;

          if (!period || !period.match(/^\d{4}-\d{2}$/)) {
            return reply
              .status(400)
              .send({ error: 'Formato de per√≠odo inv√°lido. Use YYYY-MM' });
          }

          console.log(`[API] GET /api/results/by-period - Per√≠odo: ${period}`);

          const parts = period.split('-');
          if (parts.length !== 2) {
            return reply
              .status(400)
              .send({ error: 'Formato de per√≠odo inv√°lido. Use YYYY-MM' });
          }

          const yearStr = parts[0];
          const monthStr = parts[1];

          if (!yearStr || !monthStr) {
            return reply
              .status(400)
              .send({ error: 'Formato de per√≠odo inv√°lido. Use YYYY-MM' });
          }

          const year = parseInt(yearStr, 10);
          const month = parseInt(monthStr, 10);

          if (isNaN(year) || isNaN(month) || month < 1 || month > 12) {
            return reply
              .status(400)
              .send({ error: 'Valores de ano ou m√™s inv√°lidos' });
          }

          const startDate = new Date(year, month - 1, 1);
          const endDate = new Date(year, month, 0);
          const startDateStr = startDate.toISOString().split('T')[0];
          const endDateStr = endDate.toISOString().split('T')[0];

          console.log(
            `[API] Intervalo de datas: ${startDateStr} a ${endDateStr}`
          );

          if (!startDateStr || !endDateStr) {
            return reply.status(500).send({ error: 'Erro ao formatar datas' });
          }

          const data = await rankingService.getDetailedResultsByDateRange(
            period,
            startDateStr,
            endDateStr
          );

          console.log(
            `[API] GET /api/results/by-period - Resultados encontrados: ${data.length}`
          );
          reply.send(data);
        } catch (error: any) {
          console.error(
            `[API] ERRO em /api/results/by-period: ${error.message}`,
            error
          );
          reply.status(500).send({ error: error.message || 'Erro.' });
        }
      }
    );

    interface ParamsWithId {
      id: string;
    }

    fastify.get<{ Params: ParamsWithId }>(
      '/api/results/period/:id',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        try {
          const { id } = request.params;

          const period = await periodRepository.findOne({
            where: { id: parseInt(id) },
          });

          if (!period) {
            reply
              .status(404)
              .send({ error: `Vig√™ncia com ID ${id} n√£o encontrada` });
            return;
          }

          fastify.log.info(
            `Buscando resultados para vig√™ncia ID ${id}: ${period.mesAno} (${period.status})`
          );

          const data = await rankingService.getDetailedResults(period.mesAno);
          reply.send(data);
        } catch (error: any) {
          fastify.log.error(
            `Erro em /api/results/period/${request.params.id}: ${error.message}`
          );
          reply.status(500).send({ error: error.message || 'Erro.' });
        }
      }
    );

    // === 8. ROTAS DE AUDITORIA (PROTEGIDAS) ===
    fastify.get(
      '/api/audit-logs',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('view_all_audit_logs' as any),
        ],
      },
      async (request, reply) => {
        try {
          const data = await auditLogService.getAuditLogs(50);
          reply.send(data);
        } catch (error: any) {
          fastify.log.error(`Erro em /api/audit-logs: ${error.message}`);
          reply.status(500).send({ error: error.message || 'Erro.' });
        }
      }
    );

    // === 9. ROTAS DE CRIT√âRIOS E SETORES (PROTEGIDAS) ===
    fastify.get(
      '/api/criteria/active',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        fastify.log.info('Recebida requisi√ß√£o GET /api/criteria/active');
        try {
          const criterionRepo = AppDataSource.getRepository(CriterionEntity);

          const activeCriteria = await criterionRepo.find({
            where: { ativo: true },
            select: [
              'id',
              'nome',
              'index',
              'descricao',
              'unidade_medida',
              'sentido_melhor',
              'ativo',
              'casasDecimaisPadrao',
            ],
            order: { index: 'ASC', id: 'ASC' },
          });

          if (!activeCriteria || activeCriteria.length === 0) {
            fastify.log.warn('Nenhum crit√©rio ativo encontrado no banco.');
            return reply.send([]);
          }

          fastify.log.info(
            `Retornando ${activeCriteria.length} crit√©rios ativos.`
          );
          return reply.send(activeCriteria);
        } catch (error: any) {
          fastify.log.error('Erro ao buscar crit√©rios ativos:', error);
          const errorMessage =
            error instanceof Error
              ? error.message
              : 'Erro desconhecido no servidor';
          return reply.status(500).send({
            message: 'Erro interno ao buscar crit√©rios ativos',
            error: errorMessage,
          });
        }
      }
    );

    fastify.get(
      '/api/sectors/active',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        fastify.log.info('Recebida requisi√ß√£o GET /api/sectors/active');
        try {
          const sectorRepo = AppDataSource.getRepository(SectorEntity);

          const activeSectors = await sectorRepo.find({
            where: { ativo: true },
            select: ['id', 'nome'],
            order: { nome: 'ASC' },
          });

          if (!activeSectors) {
            fastify.log.warn('Nenhum setor ativo encontrado no banco.');
            return reply.send([]);
          }

          fastify.log.info(
            `Retornando ${activeSectors.length} setores ativos.`
          );
          return reply.send(activeSectors);
        } catch (error: any) {
          fastify.log.error('Erro ao buscar setores ativos:', error);
          const errorMessage =
            error instanceof Error ? error.message : 'Erro desconhecido';
          return reply.status(500).send({
            message: 'Erro interno ao buscar setores ativos',
            error: errorMessage,
          });
        }
      }
    );

    // === 10. ROTAS DE PER√çODOS DE COMPETI√á√ÉO (PROTEGIDAS) ===
    fastify.get(
      '/api/periods/active',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        fastify.log.info('GET /api/periods/active');
        try {
          const data = await competitionPeriodService.findCurrentActivePeriod();
          if (!data) {
            return reply
              .status(404)
              .send({ message: 'Nenhum per√≠odo ativo encontrado.' });
          }
          reply.send(data);
        } catch (error: any) {
          fastify.log.error(`Erro em /api/periods/active: ${error.message}`);
          reply.status(500).send({ error: error.message || 'Erro interno.' });
        }
      }
    );

    fastify.get(
      '/api/periods/latest-closed',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        fastify.log.info('GET /api/periods/latest-closed');
        try {
          const data = await competitionPeriodService.findLatestClosedPeriod();
          if (!data) {
            return reply
              .status(404)
              .send({ message: 'Nenhum per√≠odo fechado encontrado.' });
          }
          reply.send(data);
        } catch (error: any) {
          fastify.log.error(
            `Erro em /api/periods/latest-closed: ${error.message}`
          );
          reply.status(500).send({ error: error.message || 'Erro interno.' });
        }
      }
    );

    fastify.get(
      '/api/periods/planning',
      {
        preHandler: [fastify.authenticate, manageParameters],
      },
      async (request, reply) => {
        fastify.log.info('GET /api/periods/planning');
        try {
          const data =
            await competitionPeriodService.findOrCreatePlanningPeriod();
          reply.send(data);
        } catch (error: any) {
          fastify.log.error(`Erro em /api/periods/planning: ${error.message}`);
          reply.status(500).send({ error: error.message || 'Erro interno.' });
        }
      }
    );

    fastify.get(
      '/api/periods',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        fastify.log.info('GET /api/periods');
        try {
          const data = await competitionPeriodService.findAllPeriods();
          reply.send(data);
        } catch (error: any) {
          fastify.log.error(`Erro em /api/periods: ${error.message}`);
          reply.status(500).send({ error: error.message || 'Erro interno.' });
        }
      }
    );

    fastify.post(
      '/api/periods/:id/start',
      {
        preHandler: [
          fastify.authenticate,
          startPeriods,
          auditAdminAction('START_PERIOD'),
        ],
      },
      async (request, reply) => {
        const params = request.params as { id: string };
        const periodId = parseInt(params.id, 10);

        // Usar usu√°rio autenticado real
        const actingUser = await authService.getUserById(request.user!.id);
        if (!actingUser) {
          return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
        }

        fastify.log.info(
          `POST /api/periods/${periodId}/start solicitado por ${actingUser.email}`
        );

        if (isNaN(periodId)) {
          return reply.status(400).send({ message: 'ID do per√≠odo inv√°lido.' });
        }

        try {
          if (!AppDataSource.isInitialized) await AppDataSource.initialize();

          const updatedPeriod = await competitionPeriodService.startPeriod(
            periodId,
            actingUser as any // Cast para UserEntity
          );
          reply.send(updatedPeriod);
        } catch (error: any) {
          fastify.log.error(
            `Erro em POST /api/periods/${periodId}/start: ${error.message}`
          );

          if (
            error.message.includes('n√£o encontrado') ||
            error.message.includes('inv√°lido')
          ) {
            reply.status(404).send({ error: error.message });
          } else if (error.message.includes('n√£o est√° em status')) {
            reply.status(409).send({ error: error.message });
          } else {
            reply.status(500).send({
              error: error.message || 'Erro interno ao iniciar per√≠odo.',
            });
          }
        }
      }
    );

    fastify.post(
      '/api/periods/:id/close',
      {
        preHandler: [
          fastify.authenticate,
          closePeriods,
          auditAdminAction('CLOSE_PERIOD'),
        ],
      },
      async (request, reply) => {
        const params = request.params as { id: string };
        const periodId = parseInt(params.id, 10);

        // Usar usu√°rio autenticado real
        const actingUser = await authService.getUserById(request.user!.id);
        if (!actingUser) {
          return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
        }

        fastify.log.info(
          `POST /api/periods/${periodId}/close solicitado por ${actingUser.email}`
        );

        if (isNaN(periodId)) {
          return reply.status(400).send({ message: 'ID do per√≠odo inv√°lido.' });
        }

        try {
          if (!AppDataSource.isInitialized) await AppDataSource.initialize();

          const updatedPeriod = await competitionPeriodService.closePeriod(
            periodId,
            actingUser as any // Cast para UserEntity
          );
          reply.send(updatedPeriod);
        } catch (error: any) {
          fastify.log.error(
            `Erro em POST /api/periods/${periodId}/close: ${error.message}`
          );

          if (
            error.message.includes('n√£o encontrado') ||
            error.message.includes('inv√°lido')
          ) {
            reply.status(404).send({ error: error.message });
          } else if (
            error.message.includes('n√£o est√° em status') ||
            error.message.includes('s√≥ pode ser fechado ap√≥s')
          ) {
            reply.status(409).send({ error: error.message });
          } else {
            reply.status(500).send({
              error: error.message || 'Erro interno ao fechar per√≠odo.',
            });
          }
        }
      }
    );

    // === 11. ROTAS DE PAR√ÇMETROS (PROTEGIDAS) ===
    fastify.get(
      '/api/parameters',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('view_parameters' as any),
        ],
      },
      async (request, reply) => {
        fastify.log.info('GET /api/parameters - Query Params:', request.query);

        interface GetParametersQuery {
          period?: string;
          sectorId?: string;
          criterionId?: string;
          onlyActive?: string;
        }
        const queryParams = request.query as GetParametersQuery;

        if (!queryParams.period) {
          return reply.status(400).send({
            message:
              "Query parameter 'period' (formato YYYY-MM) √© obrigat√≥rio.",
          });
        }

        const sectorIdNum = queryParams.sectorId
          ? parseInt(queryParams.sectorId, 10)
          : undefined;
        const criterionIdNum = queryParams.criterionId
          ? parseInt(queryParams.criterionId, 10)
          : undefined;
        const onlyActive = queryParams.onlyActive !== 'false';

        if (queryParams.sectorId && isNaN(sectorIdNum!)) {
          return reply.status(400).send({
            message: "Query parameter 'sectorId' deve ser um n√∫mero.",
          });
        }
        if (queryParams.criterionId && isNaN(criterionIdNum!)) {
          return reply.status(400).send({
            message: "Query parameter 'criterionId' deve ser um n√∫mero.",
          });
        }

        try {
          if (!AppDataSource.isInitialized) await AppDataSource.initialize();

          const data = await parameterService.findParametersForPeriod(
            queryParams.period,
            sectorIdNum,
            criterionIdNum,
            onlyActive
          );

          fastify.log.info(
            `GET /api/parameters - Retornando ${data.length} par√¢metros`
          );
          reply.send(data);
        } catch (error: any) {
          fastify.log.error(`Erro em GET /api/parameters: ${error.message}`);
          reply.status(500).send({
            error: error.message || 'Erro interno ao buscar par√¢metros.',
          });
        }
      }
    );

    fastify.post(
      '/api/parameters/calculate',
      {
        preHandler: [fastify.authenticate, manageParameters],
      },
      async (request, reply) => {
        const calculateData = request.body as CalculateParameterDto;

        // Usar usu√°rio autenticado real
        const actingUser = await authService.getUserById(request.user!.id);
        if (!actingUser) {
          return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
        }

        fastify.log.info(
          'POST /api/parameters/calculate com dados:',
          calculateData
        );

        try {
          if (!AppDataSource.isInitialized) await AppDataSource.initialize();

          const result = await parameterService.calculateParameter(
            calculateData,
            actingUser as any
          );
          reply.send(result);
        } catch (error: any) {
          fastify.log.error(
            `Erro em POST /api/parameters/calculate: ${error.message}`
          );

          let statusCode = 500;
          let errorMessage =
            error.message || 'Erro interno ao calcular par√¢metro.';

          if (errorMessage.includes('n√£o encontrado')) {
            statusCode = 404;
          } else if (
            errorMessage.includes('obrigat√≥rios') ||
            errorMessage.includes('N√£o h√° dados hist√≥ricos')
          ) {
            statusCode = 400;
          }

          reply.status(statusCode).send({ error: errorMessage });
        }
      }
    );

    fastify.get(
      '/api/criteria/:criterionId/calculation-settings',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('view_parameters' as any),
        ],
      },
      async (request, reply) => {
        const { criterionId } = request.params as { criterionId: string };
        const criterionIdNum = parseInt(criterionId, 10);

        if (isNaN(criterionIdNum)) {
          return reply.status(400).send({ error: 'ID do crit√©rio inv√°lido.' });
        }

        try {
          if (!AppDataSource.isInitialized) await AppDataSource.initialize();

          const criterionCalculationSettingsService =
            new CriterionCalculationSettingsService();
          const settings =
            await criterionCalculationSettingsService.getSettingsForCriterion(
              criterionIdNum
            );

          if (!settings) {
            return reply.status(404).send({
              message: `Nenhuma configura√ß√£o de c√°lculo encontrada para o crit√©rio ID: ${criterionIdNum}`,
              defaultSettings: {
                criterionId: criterionIdNum,
                calculationMethod: 'media3',
                adjustmentPercentage: 0,
                requiresRounding: true,
                roundingMethod: 'nearest',
                roundingDecimalPlaces: 0,
              },
            });
          }

          reply.send(settings);
        } catch (error: any) {
          fastify.log.error(
            `Erro em GET /api/criteria/${criterionId}/calculation-settings: ${error.message}`
          );
          reply.status(500).send({
            error:
              error.message ||
              'Erro interno ao buscar configura√ß√µes de c√°lculo.',
          });
        }
      }
    );

    fastify.get(
      '/api/parameters/:id',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('view_parameters' as any),
        ],
      },
      async (request, reply) => {
        const params = request.params as { id: string };
        const parameterId = parseInt(params.id, 10);

        fastify.log.info(`GET /api/parameters/${parameterId}`);

        if (isNaN(parameterId)) {
          return reply
            .status(400)
            .send({ message: 'ID do par√¢metro inv√°lido.' });
        }

        try {
          if (!AppDataSource.isInitialized) await AppDataSource.initialize();

          const parameter =
            await parameterService.findParameterById(parameterId);
          if (!parameter) {
            return reply.status(404).send({
              message: `Par√¢metro com ID ${parameterId} n√£o encontrado.`,
            });
          }
          reply.send(parameter);
        } catch (error: any) {
          fastify.log.error(
            `Erro em GET /api/parameters/${parameterId}: ${error.message}`
          );
          reply.status(500).send({
            error: error.message || 'Erro interno ao buscar par√¢metro.',
          });
        }
      }
    );

    fastify.put(
      '/api/parameters/:id',
      {
        preHandler: [
          fastify.authenticate,
          manageParameters,
          auditAdminAction('UPDATE_PARAMETER'),
        ],
      },
      async (request, reply) => {
        const { id } = request.params as { id: string };
        const data = request.body as UpdateParameterDto;

        fastify.log.info(`PUT /api/parameters/${id} - Dados recebidos:`, data);

        try {
          const idNum = parseInt(id, 10);
          if (isNaN(idNum)) {
            return reply.status(400).send({ message: 'ID inv√°lido.' });
          }

          // Usar usu√°rio autenticado real
          const actingUser = await authService.getUserById(request.user!.id);
          if (!actingUser) {
            return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
          }

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const updatedParameter = await parameterService.updateParameter(
            idNum,
            data,
            actingUser as any
          );

          fastify.log.info(
            `Par√¢metro ID ${id} atualizado com sucesso por ${actingUser.email}.`
          );
          reply.send(updatedParameter);
        } catch (error: any) {
          fastify.log.error(
            `Erro ao atualizar par√¢metro ID ${id}:`,
            error.message
          );

          let statusCode = 500;
          let errorMessage =
            error.message || 'Erro interno ao atualizar par√¢metro.';

          if (errorMessage.includes('n√£o encontrado')) {
            statusCode = 404;
          } else if (
            errorMessage.includes('n√£o podem ser alteradas') ||
            errorMessage.includes('Justificativa √© obrigat√≥ria') ||
            errorMessage.includes('deve estar dentro do per√≠odo') ||
            errorMessage.includes('n√£o pode ser anterior') ||
            errorMessage.includes('j√° est√° expirado')
          ) {
            statusCode = 409;
          }

          reply.status(statusCode).send({ error: errorMessage });
        }
      }
    );

    fastify.post(
      '/api/parameters',
      {
        preHandler: [
          fastify.authenticate,
          manageParameters,
          auditAdminAction('CREATE_PARAMETER'),
        ],
      },
      async (request, reply) => {
        const createData = request.body as CreateParameterDto;

        // Usar usu√°rio autenticado real
        const actingUser = await authService.getUserById(request.user!.id);
        if (!actingUser) {
          return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
        }

        fastify.log.info('POST /api/parameters com dados:', createData);

        try {
          if (!AppDataSource.isInitialized) await AppDataSource.initialize();

          const newParameter = await parameterService.createParameter(
            createData,
            actingUser as any
          );
          reply.status(201).send(newParameter);
        } catch (error: any) {
          fastify.log.error(`Erro em POST /api/parameters: ${error.message}`);
          if (
            error.message.includes('obrigat√≥rios') ||
            error.message.includes('n√£o encontrado') ||
            error.message.includes('inv√°lido')
          ) {
            reply.status(400).send({ error: error.message });
          } else if (error.message.includes('J√° existe uma meta ativa')) {
            reply.status(409).send({ error: error.message });
          } else {
            reply.status(500).send({
              error: error.message || 'Erro interno ao criar par√¢metro.',
            });
          }
        }
      }
    );

    fastify.delete(
      '/api/parameters/:id',
      {
        preHandler: [
          fastify.authenticate,
          manageParameters,
          auditAdminAction('DELETE_PARAMETER'),
        ],
      },
      async (request, reply) => {
        const params = request.params as { id: string };
        const parameterId = parseInt(params.id, 10);
        const body = request.body as { justificativa?: string };

        // Usar usu√°rio autenticado real
        const actingUser = await authService.getUserById(request.user!.id);
        if (!actingUser) {
          return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
        }

        fastify.log.info(
          `DELETE /api/parameters/${parameterId} por ${actingUser.email}`
        );

        if (isNaN(parameterId)) {
          return reply
            .status(400)
            .send({ message: 'ID do par√¢metro inv√°lido.' });
        }
        if (!body || !body.justificativa) {
          return reply.status(400).send({
            message: 'Justificativa √© obrigat√≥ria para deletar o par√¢metro.',
          });
        }

        try {
          if (!AppDataSource.isInitialized) await AppDataSource.initialize();

          const deletedParameter = await parameterService.deleteParameter(
            parameterId,
            actingUser as any,
            body.justificativa
          );
          reply.send(deletedParameter);
        } catch (error: any) {
          fastify.log.error(
            `Erro em DELETE /api/parameters/${parameterId}: ${error.message}`
          );
          if (error.message.includes('n√£o encontrado')) {
            reply.status(404).send({ error: error.message });
          } else if (
            error.message.includes('expirado') ||
            error.message.includes('n√£o pode ser deletado') ||
            error.message.includes('n√£o iniciou sua vig√™ncia')
          ) {
            reply.status(409).send({ error: error.message });
          } else {
            reply.status(500).send({
              error: error.message || 'Erro interno ao deletar par√¢metro.',
            });
          }
        }
      }
    );

    // === 12. ROTAS DE EXPURGO (PROTEGIDAS) ===
    fastify.get(
      '/api/expurgos',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('view_reports' as any, 'request_expurgos' as any),
          requireSectorAccess(),
        ],
      },
      async (request, reply) => {
        console.log('[API] GET /api/expurgos - Iniciando busca de expurgos...');

        try {
          const queryParams = request.query as {
            competitionPeriodId?: string;
            sectorId?: string;
            criterionId?: string;
            status?: string;
            dataEventoInicio?: string;
            dataEventoFim?: string;
            periodMesAno?: string;
            registradoPorUserId?: string;
            aprovadoPorUserId?: string;
            comAnexos?: string;
            valorMinimoSolicitado?: string;
            valorMaximoSolicitado?: string;
          };

          console.log('[API] Query params recebidos:', queryParams);

          const filters: any = {};

          // Converter IDs num√©ricos
          if (queryParams.competitionPeriodId) {
            const periodId = parseInt(queryParams.competitionPeriodId, 10);
            if (isNaN(periodId)) {
              return reply.status(400).send({
                error: 'competitionPeriodId deve ser um n√∫mero v√°lido',
              });
            }
            filters.competitionPeriodId = periodId;
          }

          // Suporte para busca por mesAno
          if (queryParams.periodMesAno && !filters.competitionPeriodId) {
            const period = await AppDataSource.getRepository(
              CompetitionPeriodEntity
            ).findOne({
              where: { mesAno: queryParams.periodMesAno },
            });

            if (period) {
              filters.competitionPeriodId = period.id;
              console.log(
                `[API] Convertido mesAno ${queryParams.periodMesAno} para periodId ${period.id}`
              );
            }
          }

          if (queryParams.sectorId) {
            const sectorId = parseInt(queryParams.sectorId, 10);
            if (isNaN(sectorId)) {
              return reply.status(400).send({
                error: 'sectorId deve ser um n√∫mero v√°lido',
              });
            }
            filters.sectorId = sectorId;
          }

          if (queryParams.criterionId) {
            const criterionId = parseInt(queryParams.criterionId, 10);
            if (isNaN(criterionId)) {
              return reply.status(400).send({
                error: 'criterionId deve ser um n√∫mero v√°lido',
              });
            }
            filters.criterionId = criterionId;
          }

          // Novos filtros
          if (queryParams.registradoPorUserId) {
            const userId = parseInt(queryParams.registradoPorUserId, 10);
            if (isNaN(userId)) {
              return reply.status(400).send({
                error: 'registradoPorUserId deve ser um n√∫mero v√°lido',
              });
            }
            filters.registradoPorUserId = userId;
          }

          if (queryParams.aprovadoPorUserId) {
            const userId = parseInt(queryParams.aprovadoPorUserId, 10);
            if (isNaN(userId)) {
              return reply.status(400).send({
                error: 'aprovadoPorUserId deve ser um n√∫mero v√°lido',
              });
            }
            filters.aprovadoPorUserId = userId;
          }

          if (queryParams.comAnexos !== undefined) {
            filters.comAnexos = queryParams.comAnexos === 'true';
          }

          if (queryParams.valorMinimoSolicitado) {
            const valor = parseFloat(queryParams.valorMinimoSolicitado);
            if (isNaN(valor)) {
              return reply.status(400).send({
                error: 'valorMinimoSolicitado deve ser um n√∫mero v√°lido',
              });
            }
            filters.valorMinimoSolicitado = valor;
          }

          if (queryParams.valorMaximoSolicitado) {
            const valor = parseFloat(queryParams.valorMaximoSolicitado);
            if (isNaN(valor)) {
              return reply.status(400).send({
                error: 'valorMaximoSolicitado deve ser um n√∫mero v√°lido',
              });
            }
            filters.valorMaximoSolicitado = valor;
          }

          // Validar status
          if (queryParams.status) {
            const validStatuses = [
              'PENDENTE',
              'APROVADO',
              'APROVADO_PARCIAL',
              'REJEITADO',
            ];
            if (!validStatuses.includes(queryParams.status.toUpperCase())) {
              return reply.status(400).send({
                error: `Status deve ser um de: ${validStatuses.join(', ')}`,
              });
            }
            filters.status = queryParams.status.toUpperCase();
          }

          // Filtros de data
          if (queryParams.dataEventoInicio) {
            if (!/^\d{4}-\d{2}-\d{2}$/.test(queryParams.dataEventoInicio)) {
              return reply.status(400).send({
                error: 'dataEventoInicio deve estar no formato YYYY-MM-DD',
              });
            }
            filters.dataEventoInicio = queryParams.dataEventoInicio;
          }

          if (queryParams.dataEventoFim) {
            if (!/^\d{4}-\d{2}-\d{2}$/.test(queryParams.dataEventoFim)) {
              return reply.status(400).send({
                error: 'dataEventoFim deve estar no formato YYYY-MM-DD',
              });
            }
            filters.dataEventoFim = queryParams.dataEventoFim;
          }

          console.log('[API] Filtros processados:', filters);

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const expurgos = await expurgoService.findExpurgos(filters);

          console.log(`[API] Retornando ${expurgos.length} expurgos`);
          reply.send(expurgos);
        } catch (error: any) {
          console.error('[API] Erro em GET /api/expurgos:', error);
          reply.status(500).send({
            error: error.message || 'Erro interno ao buscar expurgos.',
          });
        }
      }
    );

    fastify.get(
      '/api/expurgos/:id',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('view_reports' as any, 'request_expurgos' as any),
        ],
      },
      async (request, reply) => {
        const params = request.params as { id: string };
        const expurgoId = parseInt(params.id, 10);

        console.log(`[API] GET /api/expurgos/${expurgoId}`);

        if (isNaN(expurgoId) || expurgoId <= 0) {
          return reply.status(400).send({
            error: 'ID do expurgo deve ser um n√∫mero positivo',
          });
        }

        try {
          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const expurgo = await expurgoService.findExpurgoById(expurgoId);

          if (!expurgo) {
            return reply.status(404).send({
              message: `Expurgo com ID ${expurgoId} n√£o encontrado.`,
            });
          }

          const expurgoDto = expurgoService.convertToResponseDto(expurgo);

          console.log(`[API] Expurgo ${expurgoId} encontrado`);
          reply.send(expurgoDto);
        } catch (error: any) {
          console.error(`[API] Erro em GET /api/expurgos/${expurgoId}:`, error);
          reply.status(500).send({
            error: error.message || 'Erro interno ao buscar expurgo.',
          });
        }
      }
    );

    fastify.post(
      '/api/expurgos/request',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('request_expurgos' as any),
          auditAdminAction('REQUEST_EXPURGO'),
        ],
      },
      async (request, reply) => {
        console.log(
          '[API] POST /api/expurgos/request - Dados recebidos:',
          request.body
        );

        try {
          if (!request.body || typeof request.body !== 'object') {
            return reply.status(400).send({
              error:
                'Body da requisi√ß√£o √© obrigat√≥rio e deve ser um objeto JSON',
            });
          }

          const data = request.body as any;

          // Valida√ß√£o b√°sica de campos obrigat√≥rios
          const requiredFields = [
            'competitionPeriodId',
            'sectorId',
            'criterionId',
            'dataEvento',
            'descricaoEvento',
            'justificativaSolicitacao',
            'valorSolicitado',
          ];

          const missingFields = requiredFields.filter(
            (field) =>
              data[field] === undefined ||
              data[field] === null ||
              data[field] === ''
          );

          if (missingFields.length > 0) {
            return reply.status(400).send({
              error: `Campos obrigat√≥rios ausentes: ${missingFields.join(', ')}`,
            });
          }

          // Valida√ß√µes de tipo
          if (
            !Number.isInteger(data.competitionPeriodId) ||
            data.competitionPeriodId <= 0
          ) {
            return reply.status(400).send({
              error: 'competitionPeriodId deve ser um n√∫mero inteiro positivo',
            });
          }

          if (!Number.isInteger(data.sectorId) || data.sectorId <= 0) {
            return reply.status(400).send({
              error: 'sectorId deve ser um n√∫mero inteiro positivo',
            });
          }

          if (!Number.isInteger(data.criterionId) || data.criterionId <= 0) {
            return reply.status(400).send({
              error: 'criterionId deve ser um n√∫mero inteiro positivo',
            });
          }

          if (!/^\d{4}-\d{2}-\d{2}$/.test(data.dataEvento)) {
            return reply.status(400).send({
              error: 'dataEvento deve estar no formato YYYY-MM-DD',
            });
          }

          if (
            typeof data.descricaoEvento !== 'string' ||
            data.descricaoEvento.trim().length < 10
          ) {
            return reply.status(400).send({
              error: 'descricaoEvento deve ter pelo menos 10 caracteres',
            });
          }

          if (
            typeof data.justificativaSolicitacao !== 'string' ||
            data.justificativaSolicitacao.trim().length < 20
          ) {
            return reply.status(400).send({
              error:
                'justificativaSolicitacao deve ter pelo menos 20 caracteres',
            });
          }

          if (
            typeof data.valorSolicitado !== 'number' ||
            !isFinite(data.valorSolicitado)
          ) {
            return reply.status(400).send({
              error: 'valorSolicitado deve ser um n√∫mero v√°lido',
            });
          }

          if (data.valorSolicitado === 0) {
            return reply.status(400).send({
              error: 'valorSolicitado n√£o pode ser zero',
            });
          }

          // Criar DTO limpo
          const createExpurgoDto = {
            competitionPeriodId: data.competitionPeriodId,
            sectorId: data.sectorId,
            criterionId: data.criterionId,
            dataEvento: data.dataEvento,
            descricaoEvento: data.descricaoEvento.trim(),
            justificativaSolicitacao: data.justificativaSolicitacao.trim(),
            valorSolicitado: data.valorSolicitado,
          };

          // Usar usu√°rio autenticado real
          const requestingUser = await authService.getUserById(
            request.user!.id
          );
          if (!requestingUser) {
            return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
          }

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const newExpurgo = await expurgoService.requestExpurgo(
            createExpurgoDto,
            requestingUser as any
          );

          console.log(
            `[API] Expurgo criado com sucesso - ID: ${newExpurgo.id} por ${requestingUser.email}`
          );
          reply.status(201).send(newExpurgo);
        } catch (error: any) {
          console.error('[API] Erro em POST /api/expurgos/request:', error);

          let statusCode = 500;
          if (
            error.message.includes('n√£o encontrado') ||
            error.message.includes('n√£o encontrada')
          ) {
            statusCode = 404;
          } else if (
            error.message.includes('n√£o √© eleg√≠vel') ||
            error.message.includes('deve estar dentro') ||
            error.message.includes('j√° existe') ||
            error.message.includes('obrigat√≥rios')
          ) {
            statusCode = 400;
          } else if (error.message.includes('j√° existe um expurgo pendente')) {
            statusCode = 409;
          }

          reply.status(statusCode).send({
            error: error.message || 'Erro interno ao solicitar expurgo.',
          });
        }
      }
    );

    fastify.post(
      '/api/expurgos/:id/approve',
      {
        preHandler: [
          fastify.authenticate,
          approveExpurgos,
          auditAdminAction('APPROVE_EXPURGO'),
        ],
      },
      async (request, reply) => {
        const params = request.params as { id: string };
        const expurgoId = parseInt(params.id, 10);

        console.log(`[API] POST /api/expurgos/${expurgoId}/approve`);

        if (isNaN(expurgoId) || expurgoId <= 0) {
          return reply.status(400).send({
            error: 'ID do expurgo deve ser um n√∫mero positivo',
          });
        }

        try {
          if (!request.body || typeof request.body !== 'object') {
            return reply.status(400).send({
              error: 'Body da requisi√ß√£o √© obrigat√≥rio',
            });
          }

          const dto = request.body as any;

          if (!dto.valorAprovado || typeof dto.valorAprovado !== 'number') {
            return reply.status(400).send({
              error: 'valorAprovado √© obrigat√≥rio e deve ser um n√∫mero',
            });
          }

          if (
            !dto.justificativaAprovacao ||
            typeof dto.justificativaAprovacao !== 'string'
          ) {
            return reply.status(400).send({
              error: 'justificativaAprovacao √© obrigat√≥ria',
            });
          }

          if (dto.valorAprovado === 0) {
            return reply.status(400).send({
              error: 'valorAprovado n√£o pode ser zero',
            });
          }

          if (!isFinite(dto.valorAprovado)) {
            return reply.status(400).send({
              error: 'valorAprovado deve ser um n√∫mero v√°lido',
            });
          }

          if (dto.justificativaAprovacao.trim().length < 10) {
            return reply.status(400).send({
              error: 'justificativaAprovacao deve ter pelo menos 10 caracteres',
            });
          }

          const approveDto: ApproveExpurgoDto = {
            valorAprovado: dto.valorAprovado,
            justificativaAprovacao: dto.justificativaAprovacao.trim(),
            observacoes: dto.observacoes ? dto.observacoes.trim() : undefined,
          };

          // Usar usu√°rio autenticado real
          const approvingUser = await authService.getUserById(request.user!.id);
          if (!approvingUser) {
            return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
          }

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const approvedExpurgo = await expurgoService.approveExpurgoWithValue(
            expurgoId,
            approveDto,
            approvingUser as any
          );

          console.log(
            `[API] Expurgo ${expurgoId} aprovado com sucesso por ${approvingUser.email} - Valor: ${dto.valorAprovado}`
          );
          reply.send(approvedExpurgo);
        } catch (error: any) {
          console.error(
            `[API] Erro em POST /api/expurgos/${expurgoId}/approve:`,
            error
          );

          let statusCode = 500;
          if (
            error.message.includes('n√£o encontrado') ||
            error.message.includes('n√£o encontrada')
          ) {
            statusCode = 404;
          } else if (
            error.message.includes('n√£o pode ser aprovado') ||
            error.message.includes('n√£o pode aprovar') ||
            error.message.includes('Status atual') ||
            error.message.includes('n√£o pode ser maior')
          ) {
            statusCode = 409;
          } else if (
            error.message.includes('obrigat√≥ria') ||
            error.message.includes('deve ser')
          ) {
            statusCode = 400;
          }

          reply.status(statusCode).send({
            error: error.message || 'Erro interno ao aprovar expurgo.',
          });
        }
      }
    );

    fastify.post(
      '/api/expurgos/:id/reject',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('reject_expurgos' as any),
          auditAdminAction('REJECT_EXPURGO'),
        ],
      },
      async (request, reply) => {
        const params = request.params as { id: string };
        const expurgoId = parseInt(params.id, 10);

        console.log(`[API] POST /api/expurgos/${expurgoId}/reject`);

        if (isNaN(expurgoId) || expurgoId <= 0) {
          return reply.status(400).send({
            error: 'ID do expurgo deve ser um n√∫mero positivo',
          });
        }

        try {
          if (!request.body || typeof request.body !== 'object') {
            return reply.status(400).send({
              error: 'Body da requisi√ß√£o √© obrigat√≥rio',
            });
          }

          const dto = request.body as any;

          if (
            !dto.justificativaRejeicao ||
            typeof dto.justificativaRejeicao !== 'string' ||
            dto.justificativaRejeicao.trim().length < 10
          ) {
            return reply.status(400).send({
              error:
                'justificativaRejeicao √© obrigat√≥ria e deve ter pelo menos 10 caracteres',
            });
          }

          const rejectDto: RejectExpurgoDto = {
            justificativaRejeicao: dto.justificativaRejeicao.trim(),
            observacoes: dto.observacoes ? dto.observacoes.trim() : undefined,
          };

          // Usar usu√°rio autenticado real
          const rejectingUser = await authService.getUserById(request.user!.id);
          if (!rejectingUser) {
            return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
          }

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const rejectedExpurgo = await expurgoService.rejectExpurgo(
            expurgoId,
            rejectDto,
            rejectingUser as any
          );

          console.log(
            `[API] Expurgo ${expurgoId} rejeitado com sucesso por ${rejectingUser.email}`
          );
          reply.send(rejectedExpurgo);
        } catch (error: any) {
          console.error(
            `[API] Erro em POST /api/expurgos/${expurgoId}/reject:`,
            error
          );

          let statusCode = 500;
          if (
            error.message.includes('n√£o encontrado') ||
            error.message.includes('n√£o encontrada')
          ) {
            statusCode = 404;
          } else if (
            error.message.includes('n√£o pode ser rejeitado') ||
            error.message.includes('Status atual')
          ) {
            statusCode = 409;
          } else if (error.message.includes('obrigat√≥ria')) {
            statusCode = 400;
          }

          reply.status(statusCode).send({
            error: error.message || 'Erro interno ao rejeitar expurgo.',
          });
        }
      }
    );

    // === 13. ROTAS DE ANEXOS DE EXPURGO ===
    fastify.post(
      '/api/expurgos/:id/anexos/upload',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('request_expurgos' as any),
        ],
      },
      async (request, reply) => {
        const params = request.params as { id: string };
        const expurgoId = parseInt(params.id, 10);

        console.log(`[API] POST /api/expurgos/${expurgoId}/anexos/upload`);

        if (isNaN(expurgoId) || expurgoId <= 0) {
          return reply.status(400).send({
            error: 'ID do expurgo deve ser um n√∫mero positivo',
          });
        }

        try {
          if (!request.isMultipart()) {
            return reply.status(400).send({
              error:
                'Requisi√ß√£o deve ser multipart/form-data para upload de arquivo',
            });
          }

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const data = await request.file();

          if (!data) {
            return reply.status(400).send({
              error: 'Nenhum arquivo foi enviado',
            });
          }

          const buffer = await data.toBuffer();

          const fileData = {
            originalname: data.filename,
            buffer: buffer,
            mimetype: data.mimetype,
            size: buffer.length,
          };

          const fields = data.fields;
          const description =
            fields && (fields as any).description
              ? (fields as any).description.value
              : undefined;

          // Usar usu√°rio autenticado real
          const uploadingUser = await authService.getUserById(request.user!.id);
          if (!uploadingUser) {
            return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
          }

          const result = await expurgoService.uploadAttachment(
            expurgoId,
            fileData,
            uploadingUser as any,
            description
          );

          console.log(
            `[API] Anexo enviado com sucesso para expurgo ${expurgoId} - ID: ${result.attachment.id} por ${uploadingUser.email}`
          );

          reply.status(201).send({
            success: true,
            attachment: {
              id: result.attachment.id,
              originalFileName: result.attachment.originalFileName,
              fileSize: result.attachment.fileSize,
              mimeType: result.attachment.mimeType,
              uploadedAt: result.attachment.uploadedAt,
              description: result.attachment.description,
              downloadUrl: `/api/expurgos/anexos/${result.attachment.id}/download`,
            },
          });
        } catch (error: any) {
          console.error(
            `[API] Erro em POST /api/expurgos/${expurgoId}/anexos/upload:`,
            error
          );

          let statusCode = 500;
          if (error.message.includes('n√£o encontrado')) {
            statusCode = 404;
          } else if (
            error.message.includes('muito grande') ||
            error.message.includes('n√£o permitido') ||
            error.message.includes('n√£o √© poss√≠vel enviar')
          ) {
            statusCode = 400;
          }

          reply.status(statusCode).send({
            error: error.message || 'Erro interno ao fazer upload do anexo.',
          });
        }
      }
    );

    fastify.get(
      '/api/expurgos/:id/anexos',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('view_reports' as any, 'request_expurgos' as any),
        ],
      },
      async (request, reply) => {
        const params = request.params as { id: string };
        const expurgoId = parseInt(params.id, 10);

        console.log(`[API] GET /api/expurgos/${expurgoId}/anexos`);

        if (isNaN(expurgoId) || expurgoId <= 0) {
          return reply.status(400).send({
            error: 'ID do expurgo deve ser um n√∫mero positivo',
          });
        }

        try {
          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const anexos = await expurgoService.getExpurgoAttachments(expurgoId);

          const anexosFormatados = anexos.map((anexo) => ({
            id: anexo.id,
            originalFileName: anexo.originalFileName,
            fileSize: anexo.fileSize,
            mimeType: anexo.mimeType,
            uploadedAt: anexo.uploadedAt,
            uploadedBy: anexo.uploadedBy
              ? {
                  id: anexo.uploadedBy.id,
                  nome: anexo.uploadedBy.nome,
                }
              : undefined,
            description: anexo.description,
            downloadUrl: `/api/expurgos/anexos/${anexo.id}/download`,
            isImage: anexo.isImage(),
            isPdf: anexo.isPdf(),
            formattedSize: anexo.getFormattedFileSize(),
          }));

          console.log(
            `[API] Encontrados ${anexosFormatados.length} anexos para expurgo ${expurgoId}`
          );
          reply.send(anexosFormatados);
        } catch (error: any) {
          console.error(
            `[API] Erro em GET /api/expurgos/${expurgoId}/anexos:`,
            error
          );
          reply.status(500).send({
            error: error.message || 'Erro interno ao buscar anexos.',
          });
        }
      }
    );

    fastify.get(
      '/api/expurgos/anexos/:attachmentId/download',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('view_reports' as any, 'request_expurgos' as any),
        ],
      },
      async (request, reply) => {
        const params = request.params as { attachmentId: string };
        const attachmentId = parseInt(params.attachmentId, 10);

        console.log(`[API] GET /api/expurgos/anexos/${attachmentId}/download`);

        if (isNaN(attachmentId) || attachmentId <= 0) {
          return reply.status(400).send({
            error: 'ID do anexo deve ser um n√∫mero positivo',
          });
        }

        try {
          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          // Buscar informa√ß√µes do anexo
          const attachmentService = new (
            await import('./modules/expurgos/expurgo-attachment.service')
          ).ExpurgoAttachmentService();
          const attachment =
            await attachmentService.findAttachmentById(attachmentId);

          if (!attachment) {
            return reply.status(404).send({
              error: `Anexo com ID ${attachmentId} n√£o encontrado.`,
            });
          }

          // Obter caminho do arquivo
          const filePath =
            await expurgoService.getAttachmentDownloadPath(attachmentId);

          // Verificar se arquivo existe
          try {
            await fs.promises.access(filePath);
          } catch {
            return reply.status(404).send({
              error: 'Arquivo f√≠sico n√£o encontrado.',
            });
          }

          // Configurar headers para download
          reply.header(
            'Content-Disposition',
            `attachment; filename="${attachment.originalFileName}"`
          );
          reply.header('Content-Type', attachment.mimeType);
          reply.header('Content-Length', attachment.fileSize.toString());

          // Enviar arquivo
          const fileStream = fs.createReadStream(filePath);
          reply.send(fileStream);

          console.log(
            `[API] Download iniciado para anexo ${attachmentId}: ${attachment.originalFileName}`
          );
        } catch (error: any) {
          console.error(
            `[API] Erro em GET /api/expurgos/anexos/${attachmentId}/download:`,
            error
          );

          let statusCode = 500;
          if (error.message.includes('n√£o encontrado')) {
            statusCode = 404;
          }

          reply.status(statusCode).send({
            error: error.message || 'Erro interno ao fazer download do anexo.',
          });
        }
      }
    );

    fastify.delete(
      '/api/expurgos/anexos/:attachmentId',
      {
        preHandler: [
          fastify.authenticate,
          requirePermissions('request_expurgos' as any),
        ],
      },
      async (request, reply) => {
        const params = request.params as { attachmentId: string };
        const attachmentId = parseInt(params.attachmentId, 10);

        console.log(`[API] DELETE /api/expurgos/anexos/${attachmentId}`);

        if (isNaN(attachmentId) || attachmentId <= 0) {
          return reply.status(400).send({
            error: 'ID do anexo deve ser um n√∫mero positivo',
          });
        }

        try {
          if (!request.body || typeof request.body !== 'object') {
            return reply.status(400).send({
              error: 'Body da requisi√ß√£o √© obrigat√≥rio',
            });
          }

          const dto = request.body as any;

          if (
            !dto.reason ||
            typeof dto.reason !== 'string' ||
            dto.reason.trim().length < 10
          ) {
            return reply.status(400).send({
              error: 'reason √© obrigat√≥rio e deve ter pelo menos 10 caracteres',
            });
          }

          // Usar usu√°rio autenticado real
          const deletingUser = await authService.getUserById(request.user!.id);
          if (!deletingUser) {
            return reply.status(401).send({ error: 'Usu√°rio n√£o encontrado' });
          }

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          await expurgoService.deleteAttachment(
            attachmentId,
            deletingUser as any,
            dto.reason.trim()
          );

          console.log(
            `[API] Anexo ${attachmentId} removido com sucesso por ${deletingUser.email}`
          );
          reply.send({ success: true, message: 'Anexo removido com sucesso' });
        } catch (error: any) {
          console.error(
            `[API] Erro em DELETE /api/expurgos/anexos/${attachmentId}:`,
            error
          );

          let statusCode = 500;
          if (error.message.includes('n√£o encontrado')) {
            statusCode = 404;
          } else if (
            error.message.includes('n√£o pode remover') ||
            error.message.includes('Apenas o usu√°rio')
          ) {
            statusCode = 403;
          } else if (error.message.includes('obrigat√≥rio')) {
            statusCode = 400;
          }

          reply.status(statusCode).send({
            error: error.message || 'Erro interno ao remover anexo.',
          });
        }
      }
    );

    // === 14. ROTAS DE RELAT√ìRIOS E ESTAT√çSTICAS DE EXPURGO ===
    fastify.get(
      '/api/expurgos/statistics/advanced',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        console.log('[API] GET /api/expurgos/statistics/advanced');

        try {
          const queryParams = request.query as { period?: string };

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const stats = await expurgoService.getExpurgoStatistics(
            queryParams.period
          );

          console.log(
            `[API] Estat√≠sticas avan√ßadas geradas para per√≠odo: ${queryParams.period || 'todos'}`
          );
          reply.send(stats);
        } catch (error: any) {
          console.error(
            '[API] Erro em GET /api/expurgos/statistics/advanced:',
            error
          );
          reply.status(500).send({
            error:
              error.message || 'Erro interno ao gerar estat√≠sticas avan√ßadas.',
          });
        }
      }
    );

    fastify.get(
      '/api/expurgos/with-summary',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        console.log('[API] GET /api/expurgos/with-summary');

        try {
          const queryParams = request.query as {
            competitionPeriodId?: string;
            sectorId?: string;
            criterionId?: string;
            status?: string;
            periodMesAno?: string;
          };

          const filters: any = {};

          if (queryParams.competitionPeriodId) {
            filters.competitionPeriodId = parseInt(
              queryParams.competitionPeriodId,
              10
            );
          }

          if (queryParams.periodMesAno && !filters.competitionPeriodId) {
            const period = await AppDataSource.getRepository(
              CompetitionPeriodEntity
            ).findOne({
              where: { mesAno: queryParams.periodMesAno },
            });
            if (period) {
              filters.competitionPeriodId = period.id;
            }
          }

          if (queryParams.sectorId) {
            filters.sectorId = parseInt(queryParams.sectorId, 10);
          }

          if (queryParams.criterionId) {
            filters.criterionId = parseInt(queryParams.criterionId, 10);
          }

          if (queryParams.status) {
            filters.status = queryParams.status.toUpperCase();
          }

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const result = await expurgoService.findExpurgosWithSummary(filters);

          console.log(
            `[API] Expurgos com resumo: ${result.expurgos.length} expurgos, resumo calculado`
          );
          reply.send(result);
        } catch (error: any) {
          console.error('[API] Erro em GET /api/expurgos/with-summary:', error);
          reply.status(500).send({
            error:
              error.message || 'Erro interno ao buscar expurgos com resumo.',
          });
        }
      }
    );

    fastify.get(
      '/api/expurgos/high-impact',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        console.log('[API] GET /api/expurgos/high-impact');

        try {
          const queryParams = request.query as {
            threshold?: string;
            period?: string;
          };

          const threshold = queryParams.threshold
            ? parseFloat(queryParams.threshold)
            : 50;

          if (isNaN(threshold) || threshold <= 0) {
            return reply.status(400).send({
              error: 'threshold deve ser um n√∫mero positivo',
            });
          }

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const expurgos = await expurgoService.findHighImpactExpurgos(
            threshold,
            queryParams.period
          );

          console.log(
            `[API] Encontrados ${expurgos.length} expurgos de alto impacto (>= ${threshold})`
          );
          reply.send(expurgos);
        } catch (error: any) {
          console.error('[API] Erro em GET /api/expurgos/high-impact:', error);
          reply.status(500).send({
            error:
              error.message ||
              'Erro interno ao buscar expurgos de alto impacto.',
          });
        }
      }
    );

    fastify.get(
      '/api/expurgos/efficiency-report',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        console.log('[API] GET /api/expurgos/efficiency-report');

        try {
          const queryParams = request.query as { period?: string };

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const report = await expurgoService.getApprovalEfficiencyByCriterion(
            queryParams.period
          );

          console.log(
            `[API] Relat√≥rio de efici√™ncia gerado: ${report.length} crit√©rios analisados`
          );
          reply.send(report);
        } catch (error: any) {
          console.error(
            '[API] Erro em GET /api/expurgos/efficiency-report:',
            error
          );
          reply.status(500).send({
            error:
              error.message || 'Erro interno ao gerar relat√≥rio de efici√™ncia.',
          });
        }
      }
    );

    // === 15. ROTAS HIST√ìRICAS ===
    registerHistoricalResultsRoutes(fastify);

    fastify.get(
      '/api/history/criterion-sector',
      {
        preHandler: [fastify.authenticate, viewReports],
      },
      async (request, reply) => {
        fastify.log.info(
          'Recebida requisi√ß√£o GET /api/history/criterion-sector'
        );

        try {
          const query = request.query as {
            criterionId?: string;
            sectorId?: string;
            limit?: string;
          };

          if (!query.criterionId || !query.sectorId) {
            fastify.log.warn('Par√¢metros obrigat√≥rios ausentes:', query);
            return reply.status(400).send({
              error: 'Par√¢metros criterionId e sectorId s√£o obrigat√≥rios',
            });
          }

          const criterionId = parseInt(query.criterionId, 10);
          const sectorId = parseInt(query.sectorId, 10);
          const limit = query.limit ? parseInt(query.limit, 10) : 24;

          if (isNaN(criterionId) || isNaN(sectorId)) {
            fastify.log.warn('IDs inv√°lidos:', {
              criterionId: query.criterionId,
              sectorId: query.sectorId,
            });
            return reply.status(400).send({
              error: 'criterionId e sectorId devem ser n√∫meros v√°lidos',
            });
          }

          if (limit && (isNaN(limit) || limit < 1 || limit > 100)) {
            return reply.status(400).send({
              error: 'limit deve ser um n√∫mero entre 1 e 100',
            });
          }

          fastify.log.info(
            `Buscando hist√≥rico: criterionId=${criterionId}, sectorId=${sectorId}, limit=${limit}`
          );

          if (!AppDataSource.isInitialized) {
            await AppDataSource.initialize();
          }

          const historyData = await historyService.getCriterionSectorHistory(
            criterionId,
            sectorId,
            limit
          );

          fastify.log.info(
            `Hist√≥rico retornado: ${historyData.timeline.length} entradas, per√≠odo: ${historyData.summary.timeSpan}`
          );

          reply.send(historyData);
        } catch (error: any) {
          fastify.log.error(
            `Erro ao buscar hist√≥rico: ${error.message}`,
            error
          );

          if (error.message.includes('n√£o encontrado')) {
            reply.status(404).send({ error: error.message });
          } else if (
            error.message.includes('crit√©rio') ||
            error.message.includes('setor')
          ) {
            reply.status(400).send({ error: error.message });
          } else {
            reply.status(500).send({
              error:
                'Erro interno ao buscar hist√≥rico. Tente novamente mais tarde.',
            });
          }
        }
      }
    );

    // === 16. ROTAS ADMINISTRATIVAS (ADMIN APENAS) ===
    fastify.get(
      '/api/admin/users',
      {
        preHandler: [fastify.authenticate, manageUsers],
      },
      async (request, reply) => {
        try {
          // TODO: Implementar listagem de usu√°rios com AuthService
          reply.send({
            message: 'Lista de usu√°rios - implementar depois',
            requestedBy: request.user,
          });
        } catch (error: any) {
          fastify.log.error('Erro ao listar usu√°rios:', error);
          reply.status(500).send({ error: 'Erro interno' });
        }
      }
    );

    fastify.post(
      '/api/admin/users',
      {
        preHandler: [
          fastify.authenticate,
          manageUsers,
          auditAdminAction('CREATE_USER'),
        ],
      },
      async (request, reply) => {
        try {
          // TODO: Implementar cria√ß√£o de usu√°rios com AuthService
          reply.send({
            message: 'Criar usu√°rio - implementar depois',
            data: request.body,
            requestedBy: request.user,
          });
        } catch (error: any) {
          fastify.log.error('Erro ao criar usu√°rio:', error);
          reply.status(500).send({ error: 'Erro interno' });
        }
      }
    );

    // === 17. ROTAS DE TESTE PARA PERMISS√ïES ===
    fastify.get(
      '/api/test/permissions',
      {
        preHandler: [fastify.authenticate],
      },
      async (request, reply) => {
        return {
          message: 'Teste de permiss√µes',
          user: {
            id: request.user?.id,
            email: request.user?.email,
            roles: request.user?.roles,
            permissions: request.user?.permissions,
          },
          timestamp: new Date().toISOString(),
        };
      }
    );

    fastify.get(
      '/api/test/admin-only',
      {
        preHandler: [fastify.authenticate, adminOnly],
      },
      async (request, reply) => {
        return {
          message: '√Årea restrita - apenas diretores',
          user: request.user,
          timestamp: new Date().toISOString(),
        };
      }
    );

    fastify.get(
      '/api/test/manager-or-admin',
      {
        preHandler: [
          fastify.authenticate,
          requireRoles('DIRETOR' as any, 'GERENTE' as any),
        ],
      },
      async (request, reply) => {
        return {
          message: '√Årea para diretores e gerentes',
          user: request.user,
          timestamp: new Date().toISOString(),
        };
      }
    );

    // === 18. ERROR HANDLER GLOBAL ===
    fastify.setErrorHandler(function (error, request, reply) {
      this.log.error(
        {
          error: error.message,
          stack: error.stack,
          url: request.url,
          method: request.method,
          user: request.user?.email,
        },
        'Erro n√£o tratado'
      );

      // N√£o vazar informa√ß√µes em produ√ß√£o
      if (process.env.NODE_ENV === 'production') {
        reply.status(500).send({
          error: 'Erro interno do servidor',
          code: 'INTERNAL_ERROR',
        });
      } else {
        reply.status(500).send({
          error: error.message,
          stack: error.stack,
        });
      }
    });

    // === 19. INICIAR SERVIDOR ===
    const port = Number(process.env.API_PORT) || 3001;
    const host = process.env.HOST || '0.0.0.0';

    await fastify.listen({ port, host });

    console.log('‚úÖ Servidor iniciado com sucesso!');
    console.log(`üåê API: http://${host}:${port}`);
    console.log(`üîê Health: http://${host}:${port}/health`);
    console.log(`üìã Auth Health: http://${host}:${port}/api/health`);
    console.log('');
    console.log('üéØ ENDPOINTS DE AUTENTICA√á√ÉO:');
    console.log('  POST /api/auth/login - Login');
    console.log('  POST /api/auth/logout - Logout');
    console.log('  GET  /api/auth/me - Perfil');
    console.log('  POST /api/auth/refresh - Refresh token');
    console.log('  PUT  /api/auth/change-password - Alterar senha');
    console.log('');
    console.log('üéØ ENDPOINTS DE TESTE:');
    console.log('  GET  /api/test/permissions - Teste auth');
    console.log('  GET  /api/test/admin-only - Teste admin');
    console.log('  GET  /api/test/manager-or-admin - Teste gerente/admin');
    console.log('');
    console.log('üéØ ENDPOINTS PROTEGIDOS:');
    console.log('  GET  /api/ranking - Rankings (auth)');
    console.log('  GET  /api/results - Resultados (auth)');
    console.log('  GET  /api/parameters - Par√¢metros (view_parameters)');
    console.log('  POST /api/parameters - Criar par√¢metro (manage_parameters)');
    console.log('  GET  /api/expurgos - Expurgos (view_reports)');
    console.log(
      '  POST /api/expurgos/request - Solicitar expurgo (request_expurgos)'
    );
    console.log(
      '  POST /api/expurgos/:id/approve - Aprovar expurgo (approve_expurgos)'
    );
    console.log(
      '  POST /api/periods/:id/close - Fechar per√≠odo (close_periods)'
    );
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};

start(); // apps/api/src/server.ts
