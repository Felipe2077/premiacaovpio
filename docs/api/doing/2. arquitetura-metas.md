# üìã **DOCUMENTA√á√ÉO T√âCNICA COMPLETA**

## **Sistema de C√°lculo Autom√°tico de Metas Operacionais**

**Vers√£o:** 1.0  
**Data:** 17 de julho de 2025  
**Objetivo:** Automatizar o c√°lculo de metas para COMBUST√çVEL, PNEUS e PE√áAS integrando com o sistema de vig√™ncias existente

---

## üìë **√çNDICE**

1. [Vis√£o Geral do Sistema](#1-vis√£o-geral-do-sistema)
2. [Ciclo de Vig√™ncias e Integra√ß√£o](#2-ciclo-de-vig√™ncias-e-integra√ß√£o)
3. [Mapeamento de Fontes de Dados](#3-mapeamento-de-fontes-de-dados)
4. [Algoritmos de C√°lculo](#4-algoritmos-de-c√°lculo)
5. [Arquitetura e Implementa√ß√£o](#5-arquitetura-e-implementa√ß√£o)
6. [APIs e Endpoints](#6-apis-e-endpoints)
7. [Interface Gerencial](#7-interface-gerencial)
8. [Integra√ß√£o com Sistema Atual](#8-integra√ß√£o-com-sistema-atual)
9. [Cronograma de Implementa√ß√£o](#9-cronograma-de-implementa√ß√£o)

---

## 1. **VIS√ÉO GERAL DO SISTEMA**

### **1.1 Escopo da Funcionalidade**

- **Crit√©rios Afetados:** COMBUST√çVEL, PNEUS e PE√áAS (3 de 15 crit√©rios totais)
- **Outros Crit√©rios:** Mant√™m o sistema de pr√©-c√°lculo atual (12 crit√©rios restantes)
- **Fonte Principal:** Ser√° a **√∫nica fonte oficial** para definir metas destes 3 crit√©rios
- **Aprova√ß√£o:** Metas s√£o apresentadas para aprova√ß√£o gerencial antes da oficializa√ß√£o

### **1.2 Diferencial vs Sistema Atual**

- **Sistema Atual:** Pr√©-c√°lculo como **sugest√£o** (pode ser aceito ou rejeitado)
- **Nova Implementa√ß√£o:** C√°lculo como **fonte oficial** (deve ser aprovado para oficializar)
- **Integra√ß√£o:** Resultados salvos no mesmo `ParameterValueEntity` para manter compatibilidade

---

## 2. **CICLO DE VIG√äNCIAS E INTEGRA√á√ÉO**

### **2.1 Status das Vig√™ncias**

```
PLANEJAMENTO ‚Üí ATIVA ‚Üí PRE_FECHADA ‚Üí FECHADA
```

### **2.2 Fluxo Completo do Sistema**

#### **üìÖ Exemplo: Julho/2025 ‚Üí Agosto/2025**

```mermaid
graph TD
    A[üìÖ Julho: ATIVA<br/>Competi√ß√£o em andamento] --> B[üîÑ 01/08: Autom√°tico]
    B --> C[üìä Julho: PRE_FECHADA]
    B --> D[üìã Agosto: PLANEJAMENTO<br/>üÜï Detectar feriados automaticamente]
    C --> E[üë®‚Äçüíº Diretor confirma fechamento]
    E --> F[‚úÖ Julho: FECHADA]

    D --> G{üéØ Agosto tem feriados?}
    G -->|‚ùå N√£o| I[üë®‚Äçüíº Diretor: Calcular Metas]
    G -->|‚úÖ Sim| H[üö® OBRIGAT√ìRIO: Classificar Feriados<br/>UTIL/SABADO/DOMINGO]
    H --> J[üë®‚Äçüíº Diretor classifica cada feriado]
    J --> I[üë®‚Äçüíº Diretor: Calcular Metas]

    I --> K[üî• EXECUTAR C√ÅLCULOS:<br/>1. KM Prevista<br/>2. Combust√≠vel<br/>3. Pneus + Saldo<br/>4. Pe√ßas + Saldo]
    K --> L[üì± Apresentar resultados na tela]
    L --> M[üë®‚Äçüíº Diretor aprova/rejeita]

    M -->|‚úÖ Aprova| N[üíæ SALVAR em ParameterValueEntity<br/>Mesmo local das outras metas]
    M -->|‚ùå Rejeita| O[‚öôÔ∏è Ajustar par√¢metros]
    O --> K

    N --> P{üéØ Todas as metas definidas?<br/>15 crit√©rios √ó 4 setores}
    P -->|‚ùå N√£o| Q[üë®‚Äçüíº Definir outras metas<br/>Sistema atual]
    P -->|‚úÖ Sim| R[üöÄ Diretor: Iniciar Vig√™ncia]
    Q --> P
    R --> S[üìà Agosto: ATIVA<br/>Competi√ß√£o reinicia]
    S --> T[üîÑ Ciclo continua...]
```

### **2.3 Pontos de Integra√ß√£o Cr√≠ticos**

#### **üîÑ Trigger Autom√°tico (01 do m√™s)**

```typescript
// Evento existente que ser√° estendido
async function onNewPeriodCreated(newPeriod: CompetitionPeriodEntity) {
  if (newPeriod.status === 'PLANEJAMENTO') {
    // üÜï ADICIONAR: Detectar feriados automaticamente
    await this.operationalGoalsService.detectHolidaysForPeriod(newPeriod.id);
  }
}
```

#### **üéØ Verifica√ß√£o de Completude**

```typescript
// Antes de permitir PLANEJAMENTO ‚Üí ATIVA
async function canActivatePeriod(
  competitionPeriodId: number
): Promise<boolean> {
  // Verificar se TODOS os 15 crit√©rios √ó 4 setores t√™m metas definidas
  // Incluindo os 3 crit√©rios calculados automaticamente
}
```

---

## 3. **MAPEAMENTO DE FONTES DE DADOS**

### **3.1 Resumo Consolidado**

| Dado Necess√°rio               | Fonte       | Localiza√ß√£o                | Status           |
| ----------------------------- | ----------- | -------------------------- | ---------------- |
| **KM di√°rio por garagem**     | Oracle ERP  | Query espec√≠fica           | ‚úÖ Definida      |
| **Combust√≠vel di√°rio**        | Oracle ERP  | Mesma query KM             | ‚úÖ Definida      |
| **Custos Pneus (hist√≥rico)**  | Aplica√ß√£o   | `PerformanceDataEntity`    | ‚úÖ Dispon√≠vel    |
| **Custos Pe√ßas (hist√≥rico)**  | Aplica√ß√£o   | `PerformanceDataEntity`    | ‚úÖ Dispon√≠vel    |
| **Gasto Real (m√™s anterior)** | Aplica√ß√£o   | `PerformanceDataEntity`    | ‚úÖ Dispon√≠vel    |
| **Metas anteriores**          | Aplica√ß√£o   | `ParameterValueEntity`     | ‚úÖ Dispon√≠vel    |
| **Mapeamento Garagens**       | Aplica√ß√£o   | `SectorEntity.erp_id`      | ‚úÖ Dispon√≠vel    |
| **Feriados**                  | API Externa | Brasil API + classifica√ß√£o | üÜï A implementar |
| **Par√¢metros configur√°veis**  | Aplica√ß√£o   | Sistema atual              | ‚úÖ Dispon√≠vel    |

### **3.2 Query Oracle - KM e Combust√≠vel**

```sql
-- Query fornecida para dados di√°rios
SELECT
  A.NOMEGA,                    -- Nome da garagem
  ROUND(A.QNTCOMB, 2) AS QNTCOMB,  -- Litros consumidos
  A.KM,                        -- KM percorrido
  ROUND((A.KM / A.QNTCOMB), 2) AS KMLITRO, -- Efici√™ncia
  A.DATAABASTCARRO             -- Data da opera√ß√£o
FROM (
  SELECT
    B.NOMEGA,
    B.DATAABASTCARRO,
    SUM(B.QNTCOMB) AS QNTCOMB,
    SUM(B.KM) AS KM
  FROM (
    SELECT
      G.NOMEGA,
      T.CODIGOTPFROTA,
      T.DESCRICAOTPFROTA,
      C.DATAABASTCARRO,
      C.QTDECOMB AS QNTCOMB,
      K.KMPERCORRIDOVELOC AS KM
    FROM VWABA_CONFKMCARRO K,
         FRT_CADVEICULOS V,
         VWABA_CONSCOMBREPVEIC C,
         FRT_TIPODEFROTA T,
         CTR_GARAGEM G
    WHERE V.CODIGOVEIC = K.CODIGOVEIC
      AND V.CODIGOGA = G.CODIGOGA
      AND V.CODIGOTPFROTA = T.CODIGOTPFROTA
      AND C.CODIGOVEIC = K.CODIGOVEIC
      AND K.DATAVELOC = C.DATAABASTCARRO
      AND C.SEQUENCIAABASTCARRO = K.SEQUENCIAVELOC
      AND C.DATAABASTCARRO BETWEEN ? AND ?  -- Par√¢metros de data
      AND V.CODIGOEMPRESA = 4
      AND V.CODIGOGA BETWEEN 1 AND 9999
      AND V.PREFIXOVEIC BETWEEN '0226416' AND '9999999'
  ) B
  GROUP BY B.NOMEGA, B.DATAABASTCARRO
) A
ORDER BY A.NOMEGA, A.DATAABASTCARRO ASC
```

### **3.3 Mapeamento Oracle ‚Üî Aplica√ß√£o**

```typescript
// Tabela SectorEntity
const sectorMapping = {
  1: { nome: 'GAMA', erp_id: 240, oracleNome: 'GARAGEM GAMA' },
  2: { nome: 'PARANO√Å', erp_id: 31, oracleNome: 'GARAGEM PARANOA' },
  3: { nome: 'SANTA MARIA', erp_id: 124, oracleNome: 'GARAGEM SANTA MARIA' },
  4: {
    nome: 'S√ÉO SEBASTI√ÉO',
    erp_id: 239,
    oracleNome: 'GARAGEM SAO SEBASTIAO',
  },
};

// Fun√ß√£o de mapeamento
async function mapOracleToSector(
  oracleGarageName: string
): Promise<SectorEntity | null> {
  const mapping = {
    'GARAGEM GAMA': 240,
    'GARAGEM PARANOA': 31,
    'GARAGEM SANTA MARIA': 124,
    'GARAGEM SAO SEBASTIAO': 239,
  };

  const erpId = mapping[oracleGarageName];
  return await sectorRepo.findOne({ where: { erp_id: erpId } });
}
```

### **3.4 Estruturas de Dados Detalhadas**

#### **KM Prevista**

```typescript
interface OracleKmFuelData {
  NOMEGA: string; // "GARAGEM GAMA"
  QNTCOMB: number; // Litros consumidos no dia
  KM: number; // KM percorrido no dia
  KMLITRO: number; // Efici√™ncia KM/L
  DATAABASTCARRO: Date; // Data da opera√ß√£o
}

interface KmPrevistaCalculation {
  sectorId: number;
  monthlyData: {
    totalKm: number;
    averages: {
      diasUteis: number; // M√©dia KM em dias √∫teis
      sabados: number; // M√©dia KM em s√°bados
      domingosFeriados: number; // M√©dia KM em domingos/feriados
    };
  };
  projectedKm: number; // KM total prevista para pr√≥ximo m√™s
  calendarProjection: {
    qtdDiasUteis: number;
    qtdSabados: number;
    qtdDomingosFeriados: number;
  };
}
```

#### **Combust√≠vel**

```typescript
interface CombustivelCalculation {
  sectorId: number;
  kmPrevista: number; // Do c√°lculo anterior
  historical3Months: {
    totalKm: number; // Soma 3 meses
    totalLiters: number; // Soma 3 meses
    avgKmPerLiter: number; // Efici√™ncia m√©dia
  };
  fatorReducao: number; // Ex: 0.015 (1.5%)
  metaLitros: number; // Meta operacional
  metaReais: number; // Valor informativo
  precoPorLitro: number; // Input manual
}
```

#### **Pneus e Pe√ßas**

```typescript
interface PneusPecasCalculation {
  sectorId: number;
  criterionType: 'PNEUS' | 'PE√áAS';
  kmPrevista: number; // Do c√°lculo anterior

  // Custo m√©dio anual (√∫ltimos 12 meses)
  annualCostData: {
    totalKm12Months: number; // Soma 12 meses
    totalCost12Months: number; // Custo total 12 meses
    avgCostPerKm: number; // R$ por KM
  };

  // C√°lculo da meta base
  custoPrevistoKm: number; // kmPrevista √ó avgCostPerKm
  percentualPremiacao: number; // Ex: 0.03 (3%)
  metaBase: number; // custoPrevistoKm √ó (1 - premiacao)

  // Sistema de Saldo
  previousMonth: {
    metaAprovada: number; // ParameterValueEntity
    gastoReal: number; // PerformanceDataEntity
    percentualTolerancia: number; // Ex: 0.08 (8%)
    saldoDevedor: number; // Calculado se gasto > (meta + toler√¢ncia)
  };

  metaFinal: number; // metaBase - saldoDevedor
}
```

---

## 4. **ALGORITMOS DE C√ÅLCULO**

### **4.1 Sequ√™ncia de Execu√ß√£o**

```
1. KM PREVISTA (base para todos) ‚Üí
2. COMBUST√çVEL (usa KM + hist√≥rico) ‚Üí
3. PNEUS (usa KM + saldo) ‚Üí
4. PE√áAS (usa KM + saldo)
```

### **4.2 KM Prevista - Algoritmo Detalhado**

#### **Pr√©-requisito: Classifica√ß√£o de Feriados**

```typescript
// OBRIGAT√ìRIO: Todos os feriados devem estar classificados
async function validateHolidayClassification(
  competitionPeriodId: number
): Promise<void> {
  const unclassified = await holidayRepo.find({
    where: {
      competitionPeriodId,
      classification: IsNull(),
    },
  });

  if (unclassified.length > 0) {
    throw new Error('HOLIDAYS_NOT_CLASSIFIED');
  }
}
```

#### **Etapa A: An√°lise do M√™s de Refer√™ncia (M)**

```typescript
async function analyzeReferenceMonth(sectorId: number, referenceMonth: string) {
  // 1. Buscar dados di√°rios do Oracle
  const dailyData = await oracleService.fetchDailyKmAndFuel(
    `${referenceMonth}-01`,
    `${referenceMonth}-31`
  );

  // 2. Segmentar por tipo de dia
  const segmentedData = {
    diasUteis: [],
    sabados: [],
    domingosFeriados: [],
  };

  for (const day of dailyData) {
    const dayType = getDayType(day.DATAABASTCARRO); // Considera feriados hist√≥ricos
    segmentedData[dayType].push(day.KM);
  }

  // 3. Calcular m√©dias
  return {
    mediaKmUtil: average(segmentedData.diasUteis),
    mediaKmSabado: average(segmentedData.sabados),
    mediaKmDomFer: average(segmentedData.domingosFeriados),
  };
}
```

#### **Etapa B: Proje√ß√£o para M√™s Futuro (M+1)**

```typescript
async function projectFutureMonth(
  averages: DailyAverages,
  futureMonth: string
) {
  // 1. Contar dias por categoria (considerando classifica√ß√µes manuais)
  const calendar = await calculateMonthCalendar(futureMonth);

  // 2. Projetar KM por categoria
  const projection = {
    kmUteis: averages.mediaKmUtil * calendar.qtdDiasUteis,
    kmSabados: averages.mediaKmSabado * calendar.qtdSabados,
    kmDomingosFeriados: averages.mediaKmDomFer * calendar.qtdDomingosFeriados,
  };

  // 3. Total
  return (
    projection.kmUteis + projection.kmSabados + projection.kmDomingosFeriados
  );
}
```

### **4.3 Combust√≠vel - Algoritmo**

```typescript
async function calculateCombustivel(kmPrevista: number, sectorId: number) {
  // 1. Buscar hist√≥rico 3 meses
  const historical = await oracleService.fetchHistorical3Months(sectorId);

  // 2. Calcular m√©dia KM/L
  const totalKm = historical.reduce((sum, month) => sum + month.KM, 0);
  const totalLiters = historical.reduce((sum, month) => sum + month.QNTCOMB, 0);
  const avgKmPerLiter = totalKm / totalLiters;

  // 3. Calcular previs√£o bruta
  const litrosPrevistoBruto = kmPrevista / avgKmPerLiter;

  // 4. Aplicar fator de redu√ß√£o (par√¢metro configur√°vel)
  const fatorReducao = await getParameter('FATOR_REDUCAO_COMBUSTIVEL'); // Ex: 0.015
  const metaLitros = litrosPrevistoBruto * (1 - fatorReducao);

  // 5. Proje√ß√£o financeira (informativo)
  const precoPorLitro = await getManualInput('PRECO_COMBUSTIVEL'); // Input da tela
  const metaReais = litrosPrevistoBruto * precoPorLitro;

  return {
    metaLitros, // META OFICIAL
    metaReais, // INFORMATIVO
  };
}
```

### **4.4 Pneus e Pe√ßas - Algoritmo com Saldo**

```typescript
async function calculatePneusPecas(
  kmPrevista: number,
  sectorId: number,
  criterionType: 'PNEUS' | 'PE√áAS'
) {
  // 1. Calcular custo m√©dio anual (√∫ltimos 12 meses)
  const annualData = await appDataService.getHistoricalCosts(criterionType, 12);
  const totalKm12M = annualData.reduce((sum, month) => sum + month.totalKm, 0);
  const totalCost12M = annualData.reduce(
    (sum, month) => sum + month.totalCost,
    0
  );
  const avgCostPerKm = totalCost12M / totalKm12M;

  // 2. Calcular meta base
  const custoPrevistoKm = kmPrevista * avgCostPerKm;
  const percentualPremiacao = await getParameter(
    `PERCENTUAL_PREMIACAO_${criterionType}`
  ); // Ex: 0.03
  const metaBase = custoPrevistoKm * (1 - percentualPremiacao);

  // 3. Calcular saldo devedor do m√™s anterior
  const previousMonthData = await getPreviousMonthData(sectorId, criterionType);
  const saldoDevedor = calculateSaldoDevedor(previousMonthData);

  // 4. Meta final
  const metaFinal = metaBase - saldoDevedor;

  return {
    metaFinal, // META OFICIAL
    metaBase, // Para transpar√™ncia
    saldoDevedor, // Para auditoria
  };
}

function calculateSaldoDevedor(previousData: PreviousMonthData): number {
  const { metaAprovada, gastoReal, percentualTolerancia } = previousData;
  const tetoGasto = metaAprovada * (1 + percentualTolerancia);

  return gastoReal > tetoGasto ? gastoReal - tetoGasto : 0;
}
```

---

## 5. **ARQUITETURA E IMPLEMENTA√á√ÉO**

### **5.1 Novas Entidades (TypeORM)**

```typescript
@Entity('operational_goals_calculations')
export class OperationalGoalsCalculationEntity {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  competitionPeriodId!: number;

  @ManyToOne(() => CompetitionPeriodEntity, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'competitionPeriodId' })
  competitionPeriod!: CompetitionPeriodEntity;

  @Column('jsonb')
  calculationData!: {
    kmPrevista: Record<string, KmPrevistaCalculation>;
    combustivel: Record<string, CombustivelCalculation>;
    pneus: Record<string, PneusPecasCalculation>;
    pecas: Record<string, PneusPecasCalculation>;
  };

  @Column({
    type: 'varchar',
    enum: ['PENDING', 'COMPLETED', 'APPROVED', 'REJECTED'],
    default: 'PENDING',
  })
  status!: 'PENDING' | 'COMPLETED' | 'APPROVED' | 'REJECTED';

  @Column()
  calculatedBy!: number;

  @ManyToOne(() => UserEntity, { onDelete: 'SET NULL' })
  @JoinColumn({ name: 'calculatedBy' })
  calculatedByUser!: UserEntity;

  @Column({ nullable: true })
  approvedBy?: number;

  @Column({ type: 'timestamp with time zone', nullable: true })
  approvedAt?: Date;

  @CreateDateColumn()
  calculatedAt!: Date;

  @Column('text', { nullable: true })
  observations?: string;
}

@Entity('holiday_classifications')
export class HolidayClassificationEntity {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column('date')
  holidayDate!: string;

  @Column('varchar', { length: 100 })
  holidayName!: string;

  @Column({
    type: 'varchar',
    enum: ['UTIL', 'SABADO', 'DOMINGO_FERIADO'],
  })
  classification!: 'UTIL' | 'SABADO' | 'DOMINGO_FERIADO';

  @Column()
  competitionPeriodId!: number;

  @ManyToOne(() => CompetitionPeriodEntity, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'competitionPeriodId' })
  competitionPeriod!: CompetitionPeriodEntity;

  @Column()
  classifiedBy!: number;

  @ManyToOne(() => UserEntity, { onDelete: 'SET NULL' })
  @JoinColumn({ name: 'classifiedBy' })
  classifiedByUser!: UserEntity;

  @CreateDateColumn()
  classifiedAt!: Date;
}

@Entity('calculation_parameters')
export class CalculationParametersEntity {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column('varchar', { length: 100, unique: true })
  parameterName!: string;

  @Column('decimal', { precision: 10, scale: 6 })
  value!: number;

  @Column('text')
  description!: string;

  @Column('varchar', { length: 50 })
  category!: string; // 'COMBUSTIVEL', 'PNEUS', 'PECAS', 'GERAL'

  // üÜï ADICIONAR CAMPOS DE AUDITORIA:
  @Column('decimal', { precision: 10, scale: 6, nullable: true })
  previousValue?: number;

  @Column('text', { nullable: true })
  changeJustification?: string;

  @UpdateDateColumn()
  updatedAt!: Date;

  @Column()
  updatedBy!: number;

  @ManyToOne(() => UserEntity, { onDelete: 'SET NULL' })
  @JoinColumn({ name: 'updatedBy' })
  updatedByUser!: UserEntity;
}
```

### **5.2 Novos Servi√ßos**

#### **HolidayManagementService**

```typescript
export class HolidayManagementService {
  constructor(
    private holidayRepo: Repository<HolidayClassificationEntity>,
    private periodRepo: Repository<CompetitionPeriodEntity>
  ) {}

  async detectHolidaysForPeriod(
    competitionPeriodId: number
  ): Promise<Holiday[]> {
    const period = await this.periodRepo.findOneById(competitionPeriodId);
    const [year, month] = period.mesAno.split('-');

    // Buscar feriados da API Brasil
    const holidays = await this.fetchHolidaysFromBrasilAPI(year, month);

    // Salvar como n√£o classificados
    await this.saveUnclassifiedHolidays(competitionPeriodId, holidays);

    return holidays;
  }

  async requiresClassification(competitionPeriodId: number): Promise<boolean> {
    const unclassified = await this.holidayRepo.count({
      where: {
        competitionPeriodId,
        classification: IsNull(),
      },
    });

    return unclassified > 0;
  }

  async saveClassifications(
    competitionPeriodId: number,
    classifications: HolidayClassificationDto[],
    userId: number
  ): Promise<void> {
    for (const classification of classifications) {
      await this.holidayRepo.update(
        { competitionPeriodId, holidayDate: classification.date },
        {
          classification: classification.classification,
          classifiedBy: userId,
          classifiedAt: new Date(),
        }
      );
    }
  }

  private async fetchHolidaysFromBrasilAPI(
    year: string,
    month: string
  ): Promise<Holiday[]> {
    // Implementar chamada para https://brasilapi.com.br/api/feriados/v1/{year}
    // Filtrar por m√™s e por Bras√≠lia-DF
  }
}
```

#### **OperationalGoalsOracleService**

```typescript
export class OperationalGoalsOracleService {
  constructor(private oracleDataSource: DataSource) {}

  async fetchDailyKmAndFuel(
    startDate: string,
    endDate: string
  ): Promise<OracleKmFuelData[]> {
    const query = `
      SELECT
        A.NOMEGA,
        ROUND(A.QNTCOMB, 2) AS QNTCOMB,        
        A.KM,
        ROUND((A.KM / A.QNTCOMB), 2) AS KMLITRO,
        A.DATAABASTCARRO
      FROM (
        SELECT
          B.NOMEGA,
          B.DATAABASTCARRO,
          SUM(B.QNTCOMB) AS QNTCOMB,        
          SUM(B.KM) AS KM
        FROM (
          SELECT
            G.NOMEGA,
            T.CODIGOTPFROTA,
            T.DESCRICAOTPFROTA,
            C.DATAABASTCARRO,
            C.QTDECOMB AS QNTCOMB,        
            K.KMPERCORRIDOVELOC AS KM
          FROM VWABA_CONFKMCARRO K,
               FRT_CADVEICULOS V,
               VWABA_CONSCOMBREPVEIC C,
               FRT_TIPODEFROTA T,
               CTR_GARAGEM G
          WHERE V.CODIGOVEIC = K.CODIGOVEIC
            AND V.CODIGOGA = G.CODIGOGA
            AND V.CODIGOTPFROTA = T.CODIGOTPFROTA
            AND C.CODIGOVEIC = K.CODIGOVEIC
            AND K.DATAVELOC = C.DATAABASTCARRO
            AND C.SEQUENCIAABASTCARRO = K.SEQUENCIAVELOC    
            AND C.DATAABASTCARRO BETWEEN ? AND ?
            AND V.CODIGOEMPRESA = 4
            AND V.CODIGOGA BETWEEN 1 AND 9999
            AND V.PREFIXOVEIC BETWEEN '0226416' AND '9999999'
        ) B
        GROUP BY B.NOMEGA, B.DATAABASTCARRO
      ) A
      ORDER BY A.NOMEGA, A.DATAABASTCARRO ASC
    `;

    return await this.oracleDataSource.query(query, [startDate, endDate]);
  }

  async fetchHistorical3Months(
    sectorErpId: number
  ): Promise<HistoricalFuelData[]> {
    // Implementar busca de dados hist√≥ricos de 3 meses
    // Agrupar por m√™s para c√°lculo de m√©dia
  }
}
```

#### **OperationalGoalsAppDataService**

```typescript
export class OperationalGoalsAppDataService {
  constructor(
    private performanceRepo: Repository<PerformanceDataEntity>,
    private parameterRepo: Repository<ParameterValueEntity>,
    private criterionRepo: Repository<CriterionEntity>
  ) {}

  async getHistoricalCosts(
    criterionName: 'PNEUS' | 'PE√áAS',
    monthsBack: number = 12
  ): Promise<HistoricalCostData[]> {
    const criterion = await this.criterionRepo.findOne({
      where: { nome: criterionName },
    });

    const endDate = new Date();
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - monthsBack);

    return await this.performanceRepo.find({
      where: {
        criterionId: criterion.id,
        metricDate: Between(
          startDate.toISOString().split('T')[0],
          endDate.toISOString().split('T')[0]
        ),
      },
      relations: ['setor'],
      order: { metricDate: 'ASC' },
    });
  }

  async getPreviousMonthData(
    sectorId: number,
    criterionName: 'PNEUS' | 'PE√áAS',
    currentPeriodId: number
  ): Promise<SaldoCalculationData> {
    // Buscar per√≠odo anterior
    const currentPeriod = await this.periodRepo.findOne({
      where: { id: currentPeriodId },
    });
    const previousPeriodDate = this.getPreviousMonth(currentPeriod.mesAno);
    const previousPeriod = await this.periodRepo.findOne({
      where: { mesAno: previousPeriodDate },
    });

    if (!previousPeriod) {
      return { metaAprovada: 0, gastoReal: 0, percentualTolerancia: 0.08 };
    }

    // Buscar meta aprovada (ParameterValueEntity)
    const criterion = await this.criterionRepo.findOne({
      where: { nome: criterionName },
    });

    const metaAprovada = await this.parameterRepo.findOne({
      where: {
        competitionPeriodId: previousPeriod.id,
        sectorId,
        criterionId: criterion.id,
        dataFimEfetivo: IsNull(),
      },
    });

    // Buscar gasto real (PerformanceDataEntity)
    const gastoReal = await this.performanceRepo.findOne({
      where: {
        competitionPeriodId: previousPeriod.id,
        sectorId,
        criterionId: criterion.id,
      },
    });

    // Buscar par√¢metro de toler√¢ncia
    const tolerancia = await this.getParameter('PERCENTUAL_TOLERANCIA_SALDO');

    return {
      metaAprovada: metaAprovada ? parseFloat(metaAprovada.valor) : 0,
      gastoReal: gastoReal?.valor || 0,
      percentualTolerancia: tolerancia,
    };
  }

  private async getParameter(parameterName: string): Promise<number> {
    const param = await this.calculationParametersRepo.findOne({
      where: { parameterName },
    });
    return param?.value || 0;
  }
}
```

#### **OperationalGoalsCalculationService**

```typescript
export class OperationalGoalsCalculationService {
  constructor(
    private oracleService: OperationalGoalsOracleService,
    private appDataService: OperationalGoalsAppDataService,
    private holidayService: HolidayManagementService,
    private sectorRepo: Repository<SectorEntity>,
    private calculationRepo: Repository<OperationalGoalsCalculationEntity>
  ) {}

  async executeFullCalculation(
    competitionPeriodId: number,
    userId: number
  ): Promise<OperationalGoalsCalculationEntity> {
    // 1. Validar pr√©-requisitos
    await this.validatePrerequisites(competitionPeriodId);

    // 2. Buscar setores ativos
    const activeSectors = await this.sectorRepo.find({
      where: { ativo: true },
    });

    // 3. Executar c√°lculos para cada setor
    const results = {
      kmPrevista: {},
      combustivel: {},
      pneus: {},
      pecas: {},
    };

    for (const sector of activeSectors) {
      // KM Prevista
      const kmResult = await this.calculateKmPrevista(
        competitionPeriodId,
        sector.id
      );
      results.kmPrevista[sector.id] = kmResult;

      // Combust√≠vel
      const combustivelResult = await this.calculateCombustivel(
        kmResult.projectedKm,
        sector.erp_id
      );
      results.combustivel[sector.id] = combustivelResult;

      // Pneus
      const pneusResult = await this.calculatePneusPecas(
        kmResult.projectedKm,
        sector.id,
        'PNEUS'
      );
      results.pneus[sector.id] = pneusResult;

      // Pe√ßas
      const pecasResult = await this.calculatePneusPecas(
        kmResult.projectedKm,
        sector.id,
        'PE√áAS'
      );
      results.pecas[sector.id] = pecasResult;
    }

    // 4. Salvar c√°lculo
    const calculation = this.calculationRepo.create({
      competitionPeriodId,
      calculationData: results,
      status: 'COMPLETED',
      calculatedBy: userId,
    });

    return await this.calculationRepo.save(calculation);
  }

  private async validatePrerequisites(
    competitionPeriodId: number
  ): Promise<void> {
    // Verificar se per√≠odo est√° em PLANEJAMENTO
    const period = await this.periodRepo.findOne({
      where: { id: competitionPeriodId },
    });
    if (period?.status !== 'PLANEJAMENTO') {
      throw new Error('PERIOD_NOT_IN_PLANNING');
    }

    // Verificar se feriados est√£o classificados
    const requiresClassification =
      await this.holidayService.requiresClassification(competitionPeriodId);
    if (requiresClassification) {
      throw new Error('HOLIDAYS_NOT_CLASSIFIED');
    }
  }

  private async calculateKmPrevista(
    competitionPeriodId: number,
    sectorId: number
  ): Promise<KmPrevistaCalculation> {
    // Implementar algoritmo detalhado da se√ß√£o 4.2
    const period = await this.periodRepo.findOne({
      where: { id: competitionPeriodId },
    });
    const sector = await this.sectorRepo.findOne({ where: { id: sectorId } });

    // Buscar dados do m√™s de refer√™ncia (m√™s anterior)
    const referenceMonth = this.getPreviousMonth(period.mesAno);
    const startDate = `${referenceMonth}-01`;
    const endDate = `${referenceMonth}-31`;

    const oracleData = await this.oracleService.fetchDailyKmAndFuel(
      startDate,
      endDate
    );
    const sectorData = oracleData.filter(
      (d) => this.mapOracleToSectorId(d.NOMEGA) === sectorId
    );

    // Analisar padr√£o di√°rio e projetar para pr√≥ximo m√™s
    const averages = await this.analyzeReferenceMonth(sectorData);
    const projection = await this.projectFutureMonth(averages, period.mesAno);

    return {
      sectorId,
      monthlyData: {
        totalKm: sectorData.reduce((sum, d) => sum + d.KM, 0),
        averages,
      },
      projectedKm: projection.totalKm,
      calendarProjection: projection.calendar,
    };
  }

  private async calculateCombustivel(
    kmPrevista: number,
    sectorErpId: number
  ): Promise<CombustivelCalculation> {
    // Implementar algoritmo da se√ß√£o 4.3
    const historical =
      await this.oracleService.fetchHistorical3Months(sectorErpId);

    const totalKm = historical.reduce((sum, month) => sum + month.totalKm, 0);
    const totalLiters = historical.reduce(
      (sum, month) => sum + month.totalLiters,
      0
    );
    const avgKmPerLiter = totalKm / totalLiters;

    const litrosPrevistoBruto = kmPrevista / avgKmPerLiter;
    const fatorReducao = await this.appDataService.getParameter(
      'FATOR_REDUCAO_COMBUSTIVEL'
    );
    const metaLitros = litrosPrevistoBruto * (1 - fatorReducao);

    return {
      sectorId: this.mapErpIdToSectorId(sectorErpId),
      kmPrevista,
      historical3Months: {
        totalKm,
        totalLiters,
        avgKmPerLiter,
      },
      fatorReducao,
      metaLitros,
      metaReais: 0, // Ser√° calculado com input manual na interface
      precoPorLitro: 0,
    };
  }

  private async calculatePneusPecas(
    kmPrevista: number,
    sectorId: number,
    criterionType: 'PNEUS' | 'PE√áAS'
  ): Promise<PneusPecasCalculation> {
    // Implementar algoritmo da se√ß√£o 4.4
    const annualData = await this.appDataService.getHistoricalCosts(
      criterionType,
      12
    );
    const sectorAnnualData = annualData.filter((d) => d.sectorId === sectorId);

    const totalKm12M = sectorAnnualData.reduce(
      (sum, month) => sum + month.totalKm,
      0
    );
    const totalCost12M = sectorAnnualData.reduce(
      (sum, month) => sum + month.totalCost,
      0
    );
    const avgCostPerKm = totalCost12M / totalKm12M;

    const custoPrevistoKm = kmPrevista * avgCostPerKm;
    const percentualPremiacao = await this.appDataService.getParameter(
      `PERCENTUAL_PREMIACAO_${criterionType}`
    );
    const metaBase = custoPrevistoKm * (1 - percentualPremiacao);

    const previousMonthData = await this.appDataService.getPreviousMonthData(
      sectorId,
      criterionType,
      competitionPeriodId
    );
    const saldoDevedor = this.calculateSaldoDevedor(previousMonthData);

    return {
      sectorId,
      criterionType,
      kmPrevista,
      annualCostData: {
        totalKm12Months: totalKm12M,
        totalCost12Months: totalCost12M,
        avgCostPerKm,
      },
      custoPrevistoKm,
      percentualPremiacao,
      metaBase,
      previousMonth: {
        ...previousMonthData,
        saldoDevedor,
      },
      metaFinal: metaBase - saldoDevedor,
    };
  }

  private calculateSaldoDevedor(previousData: SaldoCalculationData): number {
    const { metaAprovada, gastoReal, percentualTolerancia } = previousData;
    const tetoGasto = metaAprovada * (1 + percentualTolerancia);

    return gastoReal > tetoGasto ? gastoReal - tetoGasto : 0;
  }
}
```

### **5.3 Extens√£o do ParameterService Existente**

```typescript
// Adicionar ao ParameterService existente
export class ParameterService {
  // ... m√©todos existentes ...

  /**
   * üÜï M√©todo para salvar metas calculadas automaticamente
   */
  async saveOperationalGoalsMetas(
    calculationId: number,
    userId: number
  ): Promise<ParameterValueEntity[]> {
    const calculation = await this.calculationRepo.findOne({
      where: { id: calculationId },
      relations: ['competitionPeriod'],
    });

    if (!calculation) {
      throw new Error('CALCULATION_NOT_FOUND');
    }

    const savedParameters: ParameterValueEntity[] = [];
    const actingUser = await this.userRepo.findOne({ where: { id: userId } });

    // Mapear crit√©rios
    const criterionMapping = {
      COMBUSTIVEL: await this.getCriterionId('COMBUST√çVEL'),
      PNEUS: await this.getCriterionId('PNEUS'),
      PECAS: await this.getCriterionId('PE√áAS'),
    };

    // Salvar para cada setor
    for (const [sectorId, results] of Object.entries(
      calculation.calculationData.combustivel
    )) {
      // üî• COMBUST√çVEL
      const combustivelParam = await this.createParameter(
        {
          criterionId: criterionMapping.COMBUSTIVEL,
          sectorId: parseInt(sectorId),
          competitionPeriodId: calculation.competitionPeriodId,
          valor: results.metaLitros.toString(),
          dataInicioEfetivo: calculation.competitionPeriod.dataInicio,
          justificativa: `Meta autom√°tica operacional - C√°lculo ID: ${calculationId}`,
          metadata: {
            calculationId,
            isOperationalGoal: true,
            algorithm: 'operational_goals_v3.0',
            calculationType: 'COMBUSTIVEL',
          },
        },
        actingUser
      );

      savedParameters.push(combustivelParam);

      // üî• PNEUS
      const pneusData = calculation.calculationData.pneus[sectorId];
      const pneusParam = await this.createParameter(
        {
          criterionId: criterionMapping.PNEUS,
          sectorId: parseInt(sectorId),
          competitionPeriodId: calculation.competitionPeriodId,
          valor: pneusData.metaFinal.toString(),
          dataInicioEfetivo: calculation.competitionPeriod.dataInicio,
          justificativa: `Meta autom√°tica operacional - C√°lculo ID: ${calculationId}`,
          metadata: {
            calculationId,
            isOperationalGoal: true,
            algorithm: 'operational_goals_v3.0',
            calculationType: 'PNEUS',
            metaBase: pneusData.metaBase,
            saldoDevedor: pneusData.previousMonth.saldoDevedor,
          },
        },
        actingUser
      );

      savedParameters.push(pneusParam);

      // üî• PE√áAS
      const pecasData = calculation.calculationData.pecas[sectorId];
      const pecasParam = await this.createParameter(
        {
          criterionId: criterionMapping.PECAS,
          sectorId: parseInt(sectorId),
          competitionPeriodId: calculation.competitionPeriodId,
          valor: pecasData.metaFinal.toString(),
          dataInicioEfetivo: calculation.competitionPeriod.dataInicio,
          justificativa: `Meta autom√°tica operacional - C√°lculo ID: ${calculationId}`,
          metadata: {
            calculationId,
            isOperationalGoal: true,
            algorithm: 'operational_goals_v3.0',
            calculationType: 'PECAS',
            metaBase: pecasData.metaBase,
            saldoDevedor: pecasData.previousMonth.saldoDevedor,
          },
        },
        actingUser
      );

      savedParameters.push(pecasParam);
    }

    // Marcar c√°lculo como aprovado
    await this.calculationRepo.update(calculationId, {
      status: 'APPROVED',
      approvedBy: userId,
      approvedAt: new Date(),
    });

    return savedParameters;
  }

  private async getCriterionId(criterionName: string): Promise<number> {
    const criterion = await this.criterionRepo.findOne({
      where: { nome: criterionName },
    });
    if (!criterion) {
      throw new Error(`Crit√©rio ${criterionName} n√£o encontrado`);
    }
    return criterion.id;
  }
}
```

---

## 6. **APIs E ENDPOINTS**

### **6.1 Novas Rotas Espec√≠ficas**

```typescript
// apps/api/src/routes/operational-goals.routes.ts
const operationalGoalsRoutes: FastifyPluginAsync = async (fastify) => {
  /**
   * GET /api/operational-goals/periods/:periodId/holidays-status
   * Verificar status de classifica√ß√£o de feriados
   */
  fastify.get<{ Params: { periodId: string } }>(
    '/api/operational-goals/periods/:periodId/holidays-status',
    {
      preHandler: [fastify.authenticate, requireViewReports],
      schema: {
        description: 'Verificar status de feriados para o per√≠odo',
        tags: ['Operational Goals'],
        params: {
          type: 'object',
          properties: {
            periodId: { type: 'string' },
          },
        },
        response: {
          200: {
            type: 'object',
            properties: {
              hasUnclassifiedHolidays: { type: 'boolean' },
              holidays: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    date: { type: 'string' },
                    name: { type: 'string' },
                    isClassified: { type: 'boolean' },
                    classification: { type: 'string', nullable: true },
                  },
                },
              },
            },
          },
        },
      },
    },
    controller.getHolidaysStatus.bind(controller)
  );

  /**
   * POST /api/operational-goals/periods/:periodId/classify-holidays
   * Classificar feriados (DIRETOR apenas)
   */
  fastify.post<{
    Params: { periodId: string };
    Body: { classifications: HolidayClassificationDto[] };
  }>(
    '/api/operational-goals/periods/:periodId/classify-holidays',
    {
      preHandler: [fastify.authenticate, requireDirectorRole],
      schema: {
        description: 'Classificar feriados do per√≠odo (somente diretores)',
        tags: ['Operational Goals'],
        params: {
          type: 'object',
          properties: {
            periodId: { type: 'string' },
          },
        },
        body: {
          type: 'object',
          properties: {
            classifications: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  date: { type: 'string' },
                  classification: {
                    type: 'string',
                    enum: ['UTIL', 'SABADO', 'DOMINGO_FERIADO'],
                  },
                },
                required: ['date', 'classification'],
              },
            },
          },
          required: ['classifications'],
        },
      },
    },
    controller.classifyHolidays.bind(controller)
  );

  /**
   * POST /api/operational-goals/periods/:periodId/calculate
   * Executar c√°lculo de metas (DIRETOR apenas)
   */
  fastify.post<{
    Params: { periodId: string };
    Body: { precoCombustivel?: number };
  }>(
    '/api/operational-goals/periods/:periodId/calculate',
    {
      preHandler: [fastify.authenticate, requireDirectorRole],
      schema: {
        description: 'Executar c√°lculo autom√°tico de metas operacionais',
        tags: ['Operational Goals'],
        params: {
          type: 'object',
          properties: {
            periodId: { type: 'string' },
          },
        },
        body: {
          type: 'object',
          properties: {
            precoCombustivel: {
              type: 'number',
              description: 'Pre√ßo por litro para c√°lculo informativo',
            },
          },
        },
        response: {
          200: {
            type: 'object',
            properties: {
              calculationId: { type: 'number' },
              status: { type: 'string' },
              results: {
                type: 'object',
                description: 'Resultados dos c√°lculos por setor',
              },
            },
          },
        },
      },
    },
    controller.calculateGoals.bind(controller)
  );

  /**
   * POST /api/operational-goals/calculations/:calculationId/approve
   * Aprovar c√°lculo e salvar como metas oficiais (DIRETOR)
   */
  fastify.post<{
    Params: { calculationId: string };
    Body: { observations?: string };
  }>(
    '/api/operational-goals/calculations/:calculationId/approve',
    {
      preHandler: [fastify.authenticate, requireDirectorRole],
      schema: {
        description: 'Aprovar c√°lculo e oficializar metas',
        tags: ['Operational Goals'],
        params: {
          type: 'object',
          properties: {
            calculationId: { type: 'string' },
          },
        },
        body: {
          type: 'object',
          properties: {
            observations: { type: 'string' },
          },
        },
      },
    },
    controller.approveCalculation.bind(controller)
  );

  /**
   * GET /api/operational-goals/calculations/:calculationId
   * Buscar detalhes de um c√°lculo espec√≠fico
   */
  fastify.get<{ Params: { calculationId: string } }>(
    '/api/operational-goals/calculations/:calculationId',
    {
      preHandler: [fastify.authenticate, requireViewReports],
      schema: {
        description: 'Buscar detalhes de c√°lculo espec√≠fico',
        tags: ['Operational Goals'],
      },
    },
    controller.getCalculationDetails.bind(controller)
  );

  /**
   * GET /api/operational-goals/parameters
   * Buscar par√¢metros configur√°veis do sistema
   */
  fastify.get(
    '/api/operational-goals/parameters',
    {
      preHandler: [fastify.authenticate, requireViewParameters],
      schema: {
        description: 'Buscar par√¢metros configur√°veis',
        tags: ['Operational Goals'],
      },
    },
    controller.getCalculationParameters.bind(controller)
  );

  /**
   * PUT /api/operational-goals/parameters/:parameterId
   * Atualizar par√¢metro espec√≠fico (DIRETOR)
   */
  fastify.put<{
    Params: { parameterId: string };
    Body: { value: number; justification: string };
  }>(
    '/api/operational-goals/parameters/:parameterId',
    {
      preHandler: [fastify.authenticate, requireDirectorRole],
      schema: {
        description: 'Atualizar par√¢metro de c√°lculo',
        tags: ['Operational Goals'],
      },
    },
    controller.updateCalculationParameter.bind(controller)
  );

  fastify.log.info('‚úÖ Rotas de Metas Operacionais registradas');
};

export default fp(operationalGoalsRoutes, {
  name: 'operational-goals-routes',
});

/**
 * GET /api/operational-goals/parameters
 * Buscar par√¢metros configur√°veis (TODOS OS USU√ÅRIOS)
 */
fastify.get(
  '/api/operational-goals/parameters',
  {
    preHandler: [fastify.authenticate],
    schema: {
      description: 'Buscar par√¢metros configur√°veis do sistema',
      tags: ['Operational Goals - Parameters'],
    },
  },
  controller.getParameters.bind(controller)
);

/**
 * PUT /api/operational-goals/parameters/:parameterName
 * Atualizar par√¢metro espec√≠fico (SOMENTE DIRETORES)
 */
fastify.put<{
  Params: { parameterName: string };
  Body: { value: number; justification: string };
}>(
  '/api/operational-goals/parameters/:parameterName',
  {
    preHandler: [fastify.authenticate, requireDirectorRole],
    schema: {
      description: 'Atualizar par√¢metro de c√°lculo (somente diretores)',
      tags: ['Operational Goals - Parameters'],
      body: {
        type: 'object',
        properties: {
          value: { type: 'number' },
          justification: { type: 'string', minLength: 10 },
        },
        required: ['value', 'justification'],
      },
    },
  },
  controller.updateParameter.bind(controller)
);
```

### **6.2 Controller Implementation**

```typescript
// apps/api/src/controllers/operational-goals.controller.ts
export class OperationalGoalsController {
  constructor(
    private holidayService: HolidayManagementService,
    private calculationService: OperationalGoalsCalculationService,
    private parameterService: ParameterService
  ) {}

  async getHolidaysStatus(
    request: FastifyRequest<{ Params: { periodId: string } }>,
    reply: FastifyReply
  ) {
    try {
      const periodId = parseInt(request.params.periodId);

      const holidays = await this.holidayService.getHolidaysForPeriod(periodId);
      const hasUnclassified =
        await this.holidayService.requiresClassification(periodId);

      return reply.send({
        hasUnclassifiedHolidays: hasUnclassified,
        holidays: holidays.map((h) => ({
          date: h.holidayDate,
          name: h.holidayName,
          isClassified: !!h.classification,
          classification: h.classification,
        })),
      });
    } catch (error) {
      request.log.error('Erro ao buscar status de feriados:', error);
      return reply.status(500).send({ error: 'Erro interno do servidor' });
    }
  }

  async classifyHolidays(
    request: FastifyRequest<{
      Params: { periodId: string };
      Body: { classifications: HolidayClassificationDto[] };
    }>,
    reply: FastifyReply
  ) {
    try {
      const periodId = parseInt(request.params.periodId);
      const { classifications } = request.body;
      const userId = request.user.id;

      await this.holidayService.saveClassifications(
        periodId,
        classifications,
        userId
      );

      return reply.send({
        success: true,
        message: 'Feriados classificados com sucesso',
      });
    } catch (error) {
      request.log.error('Erro ao classificar feriados:', error);
      return reply.status(500).send({ error: 'Erro interno do servidor' });
    }
  }

  async calculateGoals(
    request: FastifyRequest<{
      Params: { periodId: string };
      Body: { precoCombustivel?: number };
    }>,
    reply: FastifyReply
  ) {
    try {
      const periodId = parseInt(request.params.periodId);
      const userId = request.user.id;
      const { precoCombustivel } = request.body;

      const calculation = await this.calculationService.executeFullCalculation(
        periodId,
        userId
      );

      // Se pre√ßo do combust√≠vel foi informado, calcular valores informativos
      if (precoCombustivel) {
        await this.calculationService.updateCombustivelFinancialProjection(
          calculation.id,
          precoCombustivel
        );
      }

      return reply.send({
        calculationId: calculation.id,
        status: calculation.status,
        results: calculation.calculationData,
      });
    } catch (error) {
      request.log.error('Erro ao executar c√°lculo:', error);

      if (error.message === 'HOLIDAYS_NOT_CLASSIFIED') {
        return reply.status(400).send({
          error: 'Feriados n√£o classificados',
          code: 'HOLIDAYS_NOT_CLASSIFIED',
        });
      }

      if (error.message === 'PERIOD_NOT_IN_PLANNING') {
        return reply.status(400).send({
          error: 'Per√≠odo n√£o est√° em planejamento',
          code: 'PERIOD_NOT_IN_PLANNING',
        });
      }

      return reply.status(500).send({ error: 'Erro interno do servidor' });
    }
  }

  async approveCalculation(
    request: FastifyRequest<{
      Params: { calculationId: string };
      Body: { observations?: string };
    }>,
    reply: FastifyReply
  ) {
    try {
      const calculationId = parseInt(request.params.calculationId);
      const userId = request.user.id;
      const { observations } = request.body;

      // Salvar metas no sistema de vig√™ncias
      const savedParameters =
        await this.parameterService.saveOperationalGoalsMetas(
          calculationId,
          userId
        );

      // Atualizar observa√ß√µes se fornecidas
      if (observations) {
        await this.calculationService.updateCalculationObservations(
          calculationId,
          observations
        );
      }

      return reply.send({
        success: true,
        message: 'Metas aprovadas e salvas com sucesso',
        savedParameters: savedParameters.length,
      });
    } catch (error) {
      request.log.error('Erro ao aprovar c√°lculo:', error);
      return reply.status(500).send({ error: 'Erro interno do servidor' });
    }
  }

  async getCalculationDetails(
    request: FastifyRequest<{ Params: { calculationId: string } }>,
    reply: FastifyReply
  ) {
    try {
      const calculationId = parseInt(request.params.calculationId);

      const calculation =
        await this.calculationService.getCalculationById(calculationId);

      if (!calculation) {
        return reply.status(404).send({ error: 'C√°lculo n√£o encontrado' });
      }

      return reply.send(calculation);
    } catch (error) {
      request.log.error('Erro ao buscar detalhes do c√°lculo:', error);
      return reply.status(500).send({ error: 'Erro interno do servidor' });
    }
  }

  async getCalculationParameters(request: FastifyRequest, reply: FastifyReply) {
    try {
      const parameters =
        await this.calculationService.getConfigurableParameters();

      return reply.send({
        parameters,
        lastUpdated: new Date().toISOString(),
      });
    } catch (error) {
      request.log.error('Erro ao buscar par√¢metros:', error);
      return reply.status(500).send({ error: 'Erro interno do servidor' });
    }
  }

  async updateCalculationParameter(
    request: FastifyRequest<{
      Params: { parameterId: string };
      Body: { value: number; justification: string };
    }>,
    reply: FastifyReply
  ) {
    try {
      const parameterId = parseInt(request.params.parameterId);
      const { value, justification } = request.body;
      const userId = request.user.id;

      const updatedParameter = await this.calculationService.updateParameter(
        parameterId,
        value,
        justification,
        userId
      );

      return reply.send({
        success: true,
        parameter: updatedParameter,
      });
    } catch (error) {
      request.log.error('Erro ao atualizar par√¢metro:', error);
      return reply.status(500).send({ error: 'Erro interno do servidor' });
    }
  }
}
```

---

## 7. **INTERFACE GERENCIAL**

### **7.1 Fluxo na Tela de Gest√£o de Per√≠odos**

#### **Estado da Interface quando Per√≠odo em PLANEJAMENTO:**

```typescript
interface PlanningPeriodPageState {
  period: CompetitionPeriodEntity;

  // üÜï SE√á√ÉO 1: Classifica√ß√£o de Feriados
  holidaysSection: {
    hasUnclassifiedHolidays: boolean;
    holidays: Holiday[];
    allClassified: boolean;
    isClassifying: boolean;
  };

  // üÜï SE√á√ÉO 2: C√°lculo de Metas Operacionais
  operationalGoalsSection: {
    canCalculate: boolean; // = holidaysSection.allClassified
    lastCalculation?: CalculationResult;
    isCalculating: boolean;
    calculationHistory: CalculationResult[];
  };

  // ‚úÖ SE√á√ÉO 3: Outras Metas (sistema atual - 12 crit√©rios)
  otherGoalsSection: {
    definedGoals: ParameterValueEntity[];
    pendingGoals: Array<{ criterionId: number; sectorId: number }>;
  };

  // ‚úÖ SE√á√ÉO 4: A√ß√µes Gerais
  actions: {
    canActivatePeriod: boolean; // = todas as 15 √ó 4 metas definidas
    isActivating: boolean;
  };
}
```

#### **Componentes da Interface:**

```typescript
// Componente principal da p√°gina
function PlanningPeriodManagement({ periodId }: { periodId: number }) {
  const [state, setState] = useState<PlanningPeriodPageState>();

  return (
    <div className="planning-period-container">

      {/* üéØ SE√á√ÉO 1: Classifica√ß√£o de Feriados */}
      <HolidayClassificationSection
        period={state.period}
        holidays={state.holidaysSection.holidays}
        hasUnclassified={state.holidaysSection.hasUnclassifiedHolidays}
        onClassify={handleClassifyHolidays}
        isClassifying={state.holidaysSection.isClassifying}
      />

      {/* üî• SE√á√ÉO 2: C√°lculo de Metas Operacionais */}
      <OperationalGoalsCalculationSection
        period={state.period}
        canCalculate={state.operationalGoalsSection.canCalculate}
        lastCalculation={state.operationalGoalsSection.lastCalculation}
        onCalculate={handleCalculateOperationalGoals}
        onApprove={handleApproveCalculation}
        isCalculating={state.operationalGoalsSection.isCalculating}
      />

      {/* ‚úÖ SE√á√ÉO 3: Outras Metas (Sistema Atual) */}
      <OtherGoalsManagementSection
        period={state.period}
        definedGoals={state.otherGoalsSection.definedGoals}
        pendingGoals={state.otherGoalsSection.pendingGoals}
        onDefineGoal={handleDefineOtherGoal}
      />

      {/* üöÄ SE√á√ÉO 4: Ativa√ß√£o do Per√≠odo */}
      <PeriodActivationSection
        period={state.period}
        canActivate={state.actions.canActivatePeriod}
        onActivate={handleActivatePeriod}
        isActivating={state.actions.isActivating}
      />

    </div>
  );
}

// Componente de classifica√ß√£o de feriados
function HolidayClassificationSection({
  period,
  holidays,
  hasUnclassified,
  onClassify,
  isClassifying
}: HolidayClassificationSectionProps) {

  if (!hasUnclassified) {
    return (
      <Card className="mb-6">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <CheckCircle className="text-green-500" />
            Feriados Classificados
          </CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-gray-600">
            Todos os feriados de {period.mesAno} foram classificados.
          </p>
          {holidays.length > 0 && (
            <div className="mt-4">
              <h4 className="font-medium mb-2">Classifica√ß√µes:</h4>
              <div className="space-y-1">
                {holidays.map(holiday => (
                  <div key={holiday.date} className="flex justify-between text-sm">
                    <span>{holiday.name} ({holiday.date})</span>
                    <Badge variant={getClassificationVariant(holiday.classification)}>
                      {holiday.classification}
                    </Badge>
                  </div>
                ))}
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="mb-6 border-amber-200 bg-amber-50">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <AlertTriangle className="text-amber-500" />
          Classifica√ß√£o de Feriados Obrigat√≥ria
        </CardTitle>
        <CardDescription>
          Para calcular as metas operacionais, √© necess√°rio classificar todos os feriados de {period.mesAno}.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {holidays.filter(h => !h.isClassified).map(holiday => (
            <HolidayClassificationItem
              key={holiday.date}
              holiday={holiday}
              onClassify={(classification) => onClassify(holiday.date, classification)}
            />
          ))}

          <div className="flex justify-end">
            <Button
              onClick={handleSaveAllClassifications}
              disabled={isClassifying || !allHolidaysClassified}
            >
              {isClassifying ? 'Salvando...' : 'Salvar Classifica√ß√µes'}
            </Button>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

// Componente de c√°lculo de metas operacionais
function OperationalGoalsCalculationSection({
  period,
  canCalculate,
  lastCalculation,
  onCalculate,
  onApprove,
  isCalculating
}: OperationalGoalsCalculationSectionProps) {

  const [fuelPrice, setFuelPrice] = useState<number>(0);
  const [showResults, setShowResults] = useState<boolean>(false);

  return (
    <Card className="mb-6">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Calculator className="text-blue-500" />
          C√°lculo de Metas Operacionais
        </CardTitle>
        <CardDescription>
          C√°lculo autom√°tico para COMBUST√çVEL, PNEUS e PE√áAS baseado na metodologia oficial.
        </CardDescription>
      </CardHeader>
      <CardContent>

        {/* Status e Pr√©-requisitos */}
        <div className="mb-4">
          <div className="flex items-center gap-2 mb-2">
            {canCalculate ? (
              <CheckCircle className="text-green-500 w-4 h-4" />
            ) : (
              <XCircle className="text-red-500 w-4 h-4" />
            )}
            <span className="text-sm">
              {canCalculate ? 'Pronto para calcular' : 'Aguardando classifica√ß√£o de feriados'}
            </span>
          </div>
        </div>

        {/* Input de Pre√ßo do Combust√≠vel */}
        {canCalculate && (
          <div className="mb-4">
            <Label htmlFor="fuel-price">
              Pre√ßo do Combust√≠vel por Litro (para c√°lculo informativo)
            </Label>
            <Input
              id="fuel-price"
              type="number"
              step="0.001"
              placeholder="Ex: 4.462"
              value={fuelPrice}
              onChange={(e) => setFuelPrice(parseFloat(e.target.value) || 0)}
              className="mt-1"
            />
            <p className="text-xs text-gray-500 mt-1">
              Opcional: usado apenas para proje√ß√£o financeira do combust√≠vel
            </p>
          </div>
        )}

        {/* Bot√£o de C√°lculo */}
        <div className="mb-4">
          <Button
            onClick={() => onCalculate(fuelPrice)}
            disabled={!canCalculate || isCalculating}
            className="w-full"
          >
            {isCalculating ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Calculando...
              </>
            ) : (
              <>
                <Calculator className="mr-2 h-4 w-4" />
                Executar C√°lculo
              </>
            )}
          </Button>
        </div>

        {/* Resultados do C√°lculo */}
        {lastCalculation && (
          <CalculationResultsDisplay
            calculation={lastCalculation}
            onApprove={() => onApprove(lastCalculation.id)}
            onRecalculate={() => onCalculate(fuelPrice)}
          />
        )}

      </CardContent>
    </Card>
  );
}

// Componente de exibi√ß√£o de resultados
function CalculationResultsDisplay({
  calculation,
  onApprove,
  onRecalculate
}: CalculationResultsDisplayProps) {

  return (
    <div className="border rounded-lg p-4 bg-gray-50">
      <div className="flex justify-between items-center mb-4">
        <h4 className="font-medium">Resultados do C√°lculo</h4>
        <Badge variant={calculation.status === 'APPROVED' ? 'success' : 'secondary'}>
          {calculation.status}
        </Badge>
      </div>

      {/* Tabela de Resultados por Setor */}
      <div className="overflow-x-auto">
        <table className="w-full text-sm">
          <thead>
            <tr className="border-b">
              <th className="text-left p-2">Setor</th>
              <th className="text-right p-2">KM Prevista</th>
              <th className="text-right p-2">Combust√≠vel (L)</th>
              <th className="text-right p-2">Pneus (R$)</th>
              <th className="text-right p-2">Pe√ßas (R$)</th>
            </tr>
          </thead>
          <tbody>
            {Object.entries(calculation.results.kmPrevista).map(([sectorId, kmData]) => {
              const combustivel = calculation.results.combustivel[sectorId];
              const pneus = calculation.results.pneus[sectorId];
              const pecas = calculation.results.pecas[sectorId];

              return (
                <tr key={sectorId} className="border-b">
                  <td className="p-2 font-medium">{getSectorName(sectorId)}</td>
                  <td className="text-right p-2">{formatNumber(kmData.projectedKm)}</td>
                  <td className="text-right p-2">{formatNumber(combustivel.metaLitros)}</td>
                  <td className="text-right p-2">R$ {formatCurrency(pneus.metaFinal)}</td>
                  <td className="text-right p-2">R$ {formatCurrency(pecas.metaFinal)}</td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>

      {/* Detalhes Expand√≠veis */}
      <Collapsible>
        <CollapsibleTrigger className="flex items-center gap-2 mt-4 text-sm text-blue-600">
          <ChevronDown className="w-4 h-4" />
          Ver Detalhes do C√°lculo
        </CollapsibleTrigger>
        <CollapsibleContent>
          <CalculationDetailsView calculation={calculation} />
        </CollapsibleContent>
      </Collapsible>

      {/* A√ß√µes */}
      {calculation.status === 'COMPLETED' && (
        <div className="flex gap-2 mt-4">
          <Button onClick={onApprove} className="flex-1">
            <Check className="mr-2 w-4 h-4" />
            Aprovar e Oficializar
          </Button>
          <Button onClick={onRecalculate} variant="outline">
            <RefreshCw className="mr-2 w-4 h-4" />
            Recalcular
          </Button>
        </div>
      )}

      {calculation.status === 'APPROVED' && (
        <Alert className="mt-4">
          <CheckCircle className="h-4 w-4" />
          <AlertTitle>Metas Oficializadas</AlertTitle>
          <AlertDescription>
            As metas foram salvas no sistema e est√£o v√°lidas para o per√≠odo.
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
}
```

### **7.2 Sequ√™ncia de A√ß√µes do Diretor**

```mermaid
sequenceDiagram
    participant D as Diretor
    participant UI as Interface
    participant API as API
    participant DB as Database

    Note over D,DB: Per√≠odo Agosto/2025 criado automaticamente

    D->>UI: Acessa gest√£o do per√≠odo
    UI->>API: GET /periods/agosto-2025/status
    API->>DB: Verifica feriados n√£o classificados
    DB-->>API: Lista de feriados
    API-->>UI: Status: "Feriados pendentes"

    Note over UI: SE√á√ÉO 1: Classifica√ß√£o obrigat√≥ria
    D->>UI: Classifica cada feriado
    UI->>API: POST /operational-goals/periods/123/classify-holidays
    API->>DB: Salva classifica√ß√µes
    DB-->>API: Confirma√ß√£o
    API-->>UI: "Feriados classificados"

    Note over UI: SE√á√ÉO 2: C√°lculo habilitado
    D->>UI: Informa pre√ßo combust√≠vel (opcional)
    D->>UI: Clica "Executar C√°lculo"
    UI->>API: POST /operational-goals/periods/123/calculate
    API->>DB: Busca dados Oracle + Aplica√ß√£o
    API->>API: Executa algoritmos
    API->>DB: Salva resultado tempor√°rio
    DB-->>API: ID do c√°lculo
    API-->>UI: Resultados detalhados

    Note over UI: SE√á√ÉO 2: Revis√£o dos resultados
    D->>UI: Analisa resultados
    D->>UI: Clica "Aprovar e Oficializar"
    UI->>API: POST /operational-goals/calculations/456/approve
    API->>DB: Salva em ParameterValueEntity
    DB-->>API: Metas oficializadas
    API-->>UI: "Metas salvas com sucesso"

    Note over UI: SE√á√ÉO 3: Outras metas (sistema atual)
    D->>UI: Define metas dos 12 crit√©rios restantes

    Note over UI: SE√á√ÉO 4: Ativa√ß√£o habilitada
    D->>UI: Clica "Iniciar Vig√™ncia"
    UI->>API: POST /periods/123/activate
    API->>DB: Per√≠odo: PLANEJAMENTO ‚Üí ATIVA
    DB-->>API: Confirma√ß√£o
    API-->>UI: "Per√≠odo ativo"
```

#### **Menu Principal (Apenas Diretores):**

```typescript
const navigationItems = [
  // ... outros itens ...
  {
    label: "Configura√ß√£o de Metas",
    icon: Settings,
    href: "/admin/operational-goals/parameters",
    permission: "director",
    description: "Configurar par√¢metros de c√°lculo autom√°tico"
  }
];

interface ParametersConfigPageState {
  parameters: {
    FATOR_REDUCAO_COMBUSTIVEL: number;      // Ex: 0.015 (1.5%)
    PERCENTUAL_PREMIACAO_PNEUS: number;     // Ex: 0.03 (3%)
    PERCENTUAL_PREMIACAO_PECAS: number;     // Ex: 0.03 (3%)
    PERCENTUAL_TOLERANCIA_SALDO: number;    // Ex: 0.08 (8%)
  };
  isLoading: boolean;
  editingParameter: string | null;
}

// Componente da p√°gina
function OperationalGoalsParametersPage() {
  return (
    <PageContainer>
      <PageHeader
        title="Configura√ß√£o de Par√¢metros - Metas Operacionais"
        description="Ajuste os percentuais utilizados no c√°lculo autom√°tico"
      />

      <div className="grid gap-6">
        <ParameterCard
          title="Combust√≠vel - Fator de Redu√ß√£o"
          description="Percentual de redu√ß√£o aplicado sobre a previs√£o bruta"
          parameterName="FATOR_REDUCAO_COMBUSTIVEL"
          currentValue={0.015}
          format="percentage"
          example="1.5% = meta 1.5% menor que a previs√£o"
        />

        <ParameterCard
          title="Pneus - Percentual de Premia√ß√£o"
          description="Desconto aplicado na meta base como premia√ß√£o"
          parameterName="PERCENTUAL_PREMIACAO_PNEUS"
          currentValue={0.03}
          format="percentage"
          example="3% = meta 3% menor que o custo previsto"
        />

        <ParameterCard
          title="Pe√ßas - Percentual de Premia√ß√£o"
          description="Desconto aplicado na meta base como premia√ß√£o"
          parameterName="PERCENTUAL_PREMIACAO_PECAS"
          currentValue={0.03}
          format="percentage"
          example="3% = meta 3% menor que o custo previsto"
        />

        <ParameterCard
          title="Sistema de Saldo - Toler√¢ncia"
          description="Toler√¢ncia sobre a meta antes de gerar saldo devedor"
          parameterName="PERCENTUAL_TOLERANCIA_SALDO"
          currentValue={0.08}
          format="percentage"
          example="8% = gasto at√© 8% acima da meta n√£o gera saldo"
        />
      </div>
    </PageContainer>
  );
}

```

---

## 8. **INTEGRA√á√ÉO COM SISTEMA ATUAL**

### **8.1 Compatibilidade Total**

#### **‚úÖ Mesmo Storage das Outras Metas**

```typescript
// METAS CALCULADAS AUTOMATICAMENTE
const operationalGoal = await parameterRepo.save({
  criterionId: 1, // COMBUST√çVEL
  sectorId: 2, // PARANO√Å
  competitionPeriodId: 123,
  valor: '45250.75', // Meta em litros
  dataInicioEfetivo: '2025-08-01',
  dataFimEfetivo: null,
  justificativa: 'Meta autom√°tica operacional - C√°lculo ID: 456',
  metadata: {
    calculationId: 456,
    isOperationalGoal: true,
    algorithm: 'operational_goals_v3.0',
  },
});

// METAS DEFINIDAS MANUALMENTE (SISTEMA ATUAL)
const manualGoal = await parameterRepo.save({
  criterionId: 5, // ACIDENTES
  sectorId: 2, // PARANO√Å
  competitionPeriodId: 123,
  valor: '2.5', // Meta manual
  dataInicioEfetivo: '2025-08-01',
  dataFimEfetivo: null,
  justificativa: 'Meta definida manualmente pelo diretor',
  metadata: {
    isOperationalGoal: false,
  },
});

// ‚úÖ AMBAS FICAM NA MESMA TABELA: parameter_values
// ‚úÖ SISTEMA DE RANKING FUNCIONA IGUAL PARA AMBAS
// ‚úÖ INTERFACE MOSTRA TODAS AS METAS DA MESMA FORMA
```

#### **‚úÖ RankingService Continua Funcionando**

```typescript
// O RankingService atual busca todas as metas ativas
async getCurrentRanking() {
  const metas = await this.parameterRepo.find({
    where: {
      competitionPeriodId: activePeriodId,
      dataFimEfetivo: IsNull() // Metas ativas
    }
  });

  // ‚úÖ Inclui automaticamente:
  // - 3 metas calculadas automaticamente (COMBUST√çVEL, PNEUS, PE√áAS)
  // - 12 metas definidas manualmente (outros crit√©rios)
  // - Total: 15 crit√©rios √ó 4 setores = 60 metas

  return this.calculateRankingFromMetas(metas);
}
```

### **8.2 Verifica√ß√£o de Completude**

#### **Antes de Ativar Per√≠odo:**

```typescript
async function validatePeriodCanBeActivated(
  competitionPeriodId: number
): Promise<ValidationResult> {
  // Buscar todos os crit√©rios e setores ativos
  const activeCriteria = await criterionRepo.find({ where: { ativo: true } }); // 15 crit√©rios
  const activeSectors = await sectorRepo.find({ where: { ativo: true } }); // 4 setores

  const missingGoals = [];

  for (const criterion of activeCriteria) {
    for (const sector of activeSectors) {
      const hasMeta = await parameterRepo.findOne({
        where: {
          competitionPeriodId,
          criterionId: criterion.id,
          sectorId: sector.id,
          dataFimEfetivo: IsNull(),
        },
      });

      if (!hasMeta) {
        missingGoals.push({
          criterionName: criterion.nome,
          sectorName: sector.nome,
          isOperationalCriterion: ['COMBUST√çVEL', 'PNEUS', 'PE√áAS'].includes(
            criterion.nome
          ),
        });
      }
    }
  }

  return {
    canActivate: missingGoals.length === 0,
    missingGoals,
    totalRequired: activeCriteria.length * activeSectors.length, // 60 metas
    totalDefined:
      activeCriteria.length * activeSectors.length - missingGoals.length,
  };
}
```

### **8.3 Coexist√™ncia com Sistema de Pr√©-C√°lculo**

#### **Para os 12 Crit√©rios Restantes:**

```typescript
// SISTEMA ATUAL (CONTINUA FUNCIONANDO)
interface PreCalculationSuggestion {
  criterionId: number;
  sectorId: number;
  suggestedValue: number;
  calculationMethod: 'media3' | 'media6' | 'ultimo' | 'melhor3';
  canAccept: boolean; // Diretor pode aceitar ou rejeitar
  canModify: boolean; // Diretor pode modificar valor
}

// NOVA IMPLEMENTA√á√ÉO (3 CRIT√âRIOS ESPEC√çFICOS)
interface OperationalGoalsCalculation {
  criterionId: number; // COMBUST√çVEL, PNEUS ou PE√áAS
  sectorId: number;
  calculatedValue: number;
  mustApprove: boolean; // Deve ser aprovado para oficializar
  cannotModify: boolean; // Valor n√£o pode ser alterado individualmente
}
```

### **8.4 Auditoria e Transpar√™ncia**

#### **Logs Detalhados:**

```typescript
// AUDITORIA DE CADA ETAPA
await auditLogService.createLog({
  userId: directorId,
  actionType: 'OPERATIONAL_GOALS_CALCULATED',
  entityType: 'OperationalGoalsCalculation',
  entityId: calculation.id.toString(),
  details: {
    competitionPeriodId,
    sectorsProcessed: 4,
    criteriaCalculated: ['COMBUST√çVEL', 'PNEUS', 'PE√áAS'],
    totalGoalsGenerated: 12, // 3 crit√©rios √ó 4 setores
    holidaysClassified: holidayClassifications,
    parametersUsed: {
      fatorReducaoCombustivel: 0.015,
      percentualPremiacaoPneus: 0.03,
      percentualPremiacaoPecas: 0.03,
      percentualTolerancia: 0.08,
    },
  },
  justification: 'C√°lculo autom√°tico de metas operacionais',
});

await auditLogService.createLog({
  userId: directorId,
  actionType: 'OPERATIONAL_GOALS_APPROVED',
  entityType: 'ParameterValueEntity',
  entityId: 'multiple',
  details: {
    calculationId: calculation.id,
    approvedGoals: savedParameters.map((p) => ({
      criterionName: p.criterion.nome,
      sectorName: p.setor?.nome,
      value: p.valor,
      effectiveDate: p.dataInicioEfetivo,
    })),
  },
  justification: 'Aprova√ß√£o de metas calculadas automaticamente',
});
```

---

## 9. **CRONOGRAMA DE IMPLEMENTA√á√ÉO**

### **üöÄ Sprint 1: Funda√ß√£o (Semanas 1-2)**

#### **Objetivos:**

- Estabelecer infraestrutura base
- Criar entidades e servi√ßos fundamentais
- Implementar detec√ß√£o de feriados

#### **Entregas:**

```
‚úÖ Entidades TypeORM:
   - OperationalGoalsCalculationEntity
   - HolidayClassificationEntity
   - CalculationParametersEntity

‚úÖ Migra√ß√µes de banco de dados

‚úÖ Servi√ßos base:
   - HolidayManagementService
   - OperationalGoalsOracleService
   - OperationalGoalsAppDataService
   - üÜï ParametersConfigurationService

‚úÖ üÜï Tela de configura√ß√£o de par√¢metros:
   - Interface para diretores
   - Valida√ß√µes e auditoria
   - Hist√≥rico de altera√ß√µes

‚úÖ üÜï APIs de par√¢metros:
   - GET /api/operational-goals/parameters
   - PUT /api/operational-goals/parameters/:name

‚úÖ Integra√ß√£o com Brasil API (feriados)

‚úÖ Query Oracle para KM e Combust√≠vel

‚úÖ Mapeamento Oracle ‚Üî Aplica√ß√£o (erp_id)

‚úÖ Testes unit√°rios dos servi√ßos base
```

#### **Crit√©rios de Aceite:**

- ‚úÖ Detec√ß√£o autom√°tica de feriados funcional
- ‚úÖ Classifica√ß√£o manual de feriados pela interface
- ‚úÖ Query Oracle retornando dados corretos
- ‚úÖ Mapeamento de garagens funcionando

### **üî• Sprint 2: Motor de C√°lculo (Semanas 3-4)**

#### **Objetivos:**

- Implementar algoritmos de c√°lculo
- Desenvolver OperationalGoalsCalculationService
- Criar sistema de par√¢metros configur√°veis

#### **Entregas:**

```
‚úÖ OperationalGoalsCalculationService completo:
   - calculateKmPrevista()
   - calculateCombustivel()
   - calculatePneusPecas()
   - executeFullCalculation()

‚úÖ Algoritmos implementados conforme documenta√ß√£o:
   - KM Prevista (an√°lise + proje√ß√£o)
   - Combust√≠vel (m√©dia 3 meses + fator redu√ß√£o)
   - Pneus/Pe√ßas (custo anual + sistema saldo)

‚úÖ Sistema de par√¢metros configur√°veis:
   - FATOR_REDUCAO_COMBUSTIVEL
   - PERCENTUAL_PREMIACAO_PNEUS/PECAS
   - PERCENTUAL_TOLERANCIA_SALDO

‚úÖ Valida√ß√µes de neg√≥cio e tratamento de erros

‚úÖ Testes de integra√ß√£o com dados reais
```

#### **Crit√©rios de Aceite:**

- ‚úÖ C√°lculo completo executado sem erros
- ‚úÖ Resultados conferem com planilha Excel atual
- ‚úÖ Sistema de saldo calculando corretamente
- ‚úÖ Par√¢metros configur√°veis via interface

### **üîó Sprint 3: APIs e Integra√ß√£o (Semana 5)**

#### **Objetivos:**

- Criar endpoints REST
- Integrar com ParameterService existente
- Desenvolver controller e valida√ß√µes

#### **Entregas:**

```
‚úÖ Rotas REST completas:
   - GET /operational-goals/periods/:id/holidays-status
   - POST /operational-goals/periods/:id/classify-holidays
   - POST /operational-goals/periods/:id/calculate
   - POST /operational-goals/calculations/:id/approve
   - GET /operational-goals/parameters

‚úÖ OperationalGoalsController implementado

‚úÖ Integra√ß√£o com ParameterService:
   - saveOperationalGoalsMetas()
   - Metas salvas no mesmo ParameterValueEntity

‚úÖ Valida√ß√µes de entrada e autoriza√ß√£o

‚úÖ Documenta√ß√£o Swagger

‚úÖ Testes de API (Postman/Insomnia)
```

#### **Crit√©rios de Aceite:**

- ‚úÖ Todas as APIs funcionando corretamente
- ‚úÖ Metas salvas no sistema de vig√™ncias
- ‚úÖ Autoriza√ß√£o funcionando (apenas diretores)
- ‚úÖ Documenta√ß√£o API atualizada

### **üé® Sprint 4: Interface Gerencial (Semana 6)**

#### **Objetivos:**

- Implementar interface do usu√°rio
- Integrar com APIs
- Testes de aceita√ß√£o

#### **Entregas:**

```
‚úÖ Componentes React:
   - HolidayClassificationSection
   - OperationalGoalsCalculationSection
   - CalculationResultsDisplay
   - PeriodActivationSection

‚úÖ Integra√ß√£o com APIs REST

‚úÖ Estados de loading e feedback

‚úÖ Valida√ß√µes de entrada no frontend

‚úÖ Design responsivo e acess√≠vel

‚úÖ Testes end-to-end
```

#### **Crit√©rios de Aceite:**

- ‚úÖ Fluxo completo funcionando na interface
- ‚úÖ Diretor consegue classificar feriados
- ‚úÖ C√°lculo e aprova√ß√£o funcionais
- ‚úÖ Per√≠odo pode ser ativado ap√≥s todas as metas

### **üöÄ Sprint 5: Homologa√ß√£o e Deploy (Semana 7)**

#### **Objetivos:**

- Testes em ambiente de produ√ß√£o
- Treinamento da equipe
- Deploy seguro

#### **Entregas:**

```
‚úÖ Testes de carga e performance

‚úÖ Backup e restore testados

‚úÖ Monitoramento configurado

‚úÖ Documenta√ß√£o para usu√°rios finais

‚úÖ Treinamento de diretores

‚úÖ Deploy em produ√ß√£o

‚úÖ Valida√ß√£o com dados reais
```

#### **Crit√©rios de Aceite:**

- ‚úÖ Sistema funcionando em produ√ß√£o
- ‚úÖ Primeiro per√≠odo calculado com sucesso
- ‚úÖ Equipe treinada e confiante
- ‚úÖ Monitoramento ativo

---

## 10. **CONSIDERA√á√ïES FINAIS**

### **10.1 Pontos Cr√≠ticos de Aten√ß√£o**

#### **üî¥ Dados Oracle**

- **Valida√ß√£o cont√≠nua:** Garantir que a query Oracle continue retornando dados consistentes
- **Backup de dados:** Manter hist√≥rico de dados para reprocessamento se necess√°rio
- **Monitoramento:** Alertas se dados Oracle ficarem indispon√≠veis

#### **üî¥ Sistema de Saldo**

- **Valida√ß√£o cruzada:** Conferir c√°lculos de saldo com planilhas existentes
- **Transpar√™ncia:** Logs detalhados de como cada saldo foi calculado
- **Auditoria:** Rastreabilidade completa das opera√ß√µes

#### **üî¥ Integra√ß√£o com Sistema Atual**

- **Compatibilidade:** Garantir que nada seja quebrado no sistema existente
- **Migra√ß√£o suave:** Implementar com flag de feature toggle se necess√°rio
- **Rollback:** Plano para voltar ao sistema manual se necess√°rio

### **10.2 Benef√≠cios Esperados**

#### **‚úÖ Operacionais**

- **Elimina√ß√£o de planilhas:** Redu√ß√£o de 95% no tempo de c√°lculo manual
- **Consist√™ncia:** Aplica√ß√£o uniforme da metodologia oficial
- **Auditoria:** Rastreabilidade completa de todos os c√°lculos
- **Transpar√™ncia:** Visibilidade total dos par√¢metros e algoritmos

#### **‚úÖ Estrat√©gicos**

- **Confiabilidade:** Redu√ß√£o de erros humanos a praticamente zero
- **Agilidade:** Per√≠odo pode ser ativado no mesmo dia que √© criado
- **Escalabilidade:** Sistema preparado para novos crit√©rios ou mudan√ßas
- **Governan√ßa:** Controle total sobre par√¢metros e aprova√ß√µes

### **10.3 Riscos e Mitiga√ß√µes**

#### **‚ö†Ô∏è Riscos T√©cnicos**

- **Oracle indispon√≠vel:** Implementar cache e retry autom√°tico
- **Dados inconsistentes:** Valida√ß√µes m√∫ltiplas e alertas autom√°ticos
- **Performance:** Otimizar queries e implementar processamento ass√≠ncrono

#### **‚ö†Ô∏è Riscos de Neg√≥cio**

- **Resist√™ncia √† mudan√ßa:** Treinamento adequado e per√≠odo de transi√ß√£o
- **Confian√ßa nos c√°lculos:** Valida√ß√£o paralela com Excel por 2-3 meses
- **Aprova√ß√£o gerencial:** Demonstra√ß√µes e provas de conceito

### **10.4 M√©tricas de Sucesso**

#### **üìä Metas Quantitativas**

- **Tempo de c√°lculo:** De 4 horas para 15 minutos (redu√ß√£o de 94%)
- **Precis√£o:** 100% de ader√™ncia √† metodologia oficial
- **Disponibilidade:** 99.9% de uptime do sistema
- **Ado√ß√£o:** 100% dos diretores usando o sistema em 30 dias

#### **üìä Metas Qualitativas**

- **Satisfa√ß√£o:** Feedback positivo de 90%+ dos usu√°rios
- **Confian√ßa:** Aprova√ß√£o un√¢nime da diretoria
- **Transpar√™ncia:** Redu√ß√£o de 100% das d√∫vidas sobre c√°lculos
- **Efici√™ncia:** Ativa√ß√£o de per√≠odos no mesmo dia da cria√ß√£o

---

## üìö **ANEXOS**

### **A. Refer√™ncias T√©cnicas**

- Documenta√ß√£o original do sistema de metas (vers√£o 3.0)
- An√°lise da API atual (estruturas e padr√µes)
- Query Oracle validada para KM e combust√≠vel
- Mapeamento de entidades e relacionamentos

### **B. Configura√ß√µes de Ambiente**

- Vari√°veis de ambiente necess√°rias
- Configura√ß√µes do Oracle Instant Client
- Par√¢metros de configura√ß√£o da API Brasil
- Scripts de migra√ß√£o do banco de dados

### **C. Planos de Teste**

- Casos de teste unit√°rios
- Cen√°rios de teste de integra√ß√£o
- Scripts de teste de carga
- Crit√©rios de aceita√ß√£o detalhados

---

**üìã Esta documenta√ß√£o serve como guia completo para implementa√ß√£o do Sistema de C√°lculo Autom√°tico de Metas Operacionais, cobrindo todos os aspectos t√©cnicos, funcionais e operacionais necess√°rios para o sucesso do projeto.**
