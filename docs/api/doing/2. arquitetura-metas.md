# üìã **DOCUMENTA√á√ÉO T√âCNICA CORRIGIDA**

## **Sistema de C√°lculo Autom√°tico de Metas Operacionais**

**Vers√£o:** 2.0 (Revisada)  
**Data:** 17 de julho de 2025  
**Objetivo:** Automatizar o c√°lculo de metas para COMBUST√çVEL, PNEUS e PE√áAS aproveitando a infraestrutura existente da API

---

## üìë **√çNDICE**

1. [Vis√£o Geral do Sistema](#1-vis√£o-geral-do-sistema)
2. [Integra√ß√£o com Arquitetura Existente](#2-integra√ß√£o-com-arquitetura-existente)
3. [Mapeamento de Fontes de Dados Reais](#3-mapeamento-de-fontes-de-dados-reais)
4. [Algoritmos de C√°lculo](#4-algoritmos-de-c√°lculo)
5. [Implementa√ß√£o Baseada na API Real](#5-implementa√ß√£o-baseada-na-api-real)
6. [APIs e Endpoints](#6-apis-e-endpoints)
7. [Interface Gerencial](#7-interface-gerencial)
8. [Cronograma de Implementa√ß√£o](#8-cronograma-de-implementa√ß√£o)

---

## 1. **VIS√ÉO GERAL DO SISTEMA**

### **1.1 Escopo da Funcionalidade**

- **Crit√©rios Afetados:** COMBUST√çVEL, PNEUS e PE√áAS (3 de 15 crit√©rios totais)
- **Outros Crit√©rios:** Mant√™m o sistema de pr√©-c√°lculo atual (12 crit√©rios restantes)
- **Fonte Principal:** Ser√° a **√∫nica fonte oficial** para definir metas destes 3 crit√©rios
- **Aprova√ß√£o:** Metas s√£o apresentadas para aprova√ß√£o gerencial antes da oficializa√ß√£o

### **1.2 Integra√ß√£o com Sistema Existente**

- **‚úÖ Aproveitar:** `CompetitionPeriodEntity` com status PLANEJAMENTO ‚Üí ATIVA
- **‚úÖ Aproveitar:** `ParameterValueEntity` para salvar metas calculadas
- **‚úÖ Aproveitar:** `OracleEtlService` e Raw Entities existentes
- **‚úÖ Aproveitar:** Sistema de auditoria `AuditLogEntity`
- **üÜï Adicionar:** Apenas funcionalidades espec√≠ficas necess√°rias

---

## 2. **INTEGRA√á√ÉO COM ARQUITETURA EXISTENTE**

### **2.1 Aproveitamento da Infraestrutura Atual**

```
PLANEJAMENTO ‚Üí ATIVA ‚Üí PRE_FECHADA ‚Üí FECHADA
```

#### **‚úÖ Sistema ETL Oracle - J√Å FUNCIONAL**

```typescript
// USAR O QUE J√Å EXISTE:
export class OracleEtlService {
  // ‚úÖ Conex√£o Oracle configurada
  // ‚úÖ Mapeamento de garagens existente:
  if (item.CODIGOGA == '31') sectorName = 'PARANO√Å';
  else if (item.CODIGOGA == '124') sectorName = 'SANTA MARIA';
  else if (item.CODIGOGA == '239') sectorName = 'S√ÉO SEBASTI√ÉO';
  else if (item.CODIGOGA == '240') sectorName = 'GAMA';

  // ‚úÖ Raw Entities j√° criadas e funcionais
}

// üÜï ESTENDER (n√£o duplicar):
export class OperationalGoalsOracleService extends OracleEtlService {
  // Apenas queries espec√≠ficas para metas operacionais
  async fetchDailyKmAndFuelForGoals(startDate: string, endDate: string): Promise<OracleKmFuelData[]>
  async fetchHistorical3MonthsForGoals(sectorCode: string): Promise<HistoricalFuelData[]>
}
```

#### **‚úÖ Sistema de Par√¢metros - USAR EXISTENTE**

```typescript
// ‚úÖ USAR ParameterValueEntity EXISTENTE para metas:
const metaCombustivel = await parameterService.createParameter({
  criterionId: combustivelCriterion.id,
  sectorId: gamaSetor.id,
  competitionPeriodId: agosto2025.id,
  valor: '45250.75', // Meta calculada em litros
  justificativa: 'Meta autom√°tica operacional',
  metadata: {
    isOperationalGoal: true,
    calculationId: 123,
  },
});

// üÜï ADICIONAR APENAS para par√¢metros de configura√ß√£o globais:
@Entity('operational_goals_parameters')
export class OperationalGoalsParametersEntity {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column('varchar', { length: 100, unique: true })
  parameterName!: string; // 'FATOR_REDUCAO_COMBUSTIVEL'

  @Column('decimal', { precision: 10, scale: 6 })
  value!: number; // 0.015

  @Column('text')
  description!: string;
}
```

#### **‚úÖ Raw Data - APROVEITAR EXISTENTES**

```typescript
// ‚úÖ J√Å EXISTE e FUNCIONA:
@Entity({ name: 'raw_oracle_fleet_performance' })
export class RawOracleFleetPerformanceEntity {
  metricMonth!: string; // '2025-07'
  sectorName!: string; // 'SANTA MARIA'
  totalKm!: number; // KM do m√™s
  totalFuelLiters!: number; // Litros do m√™s
  avgKmL!: number; // Efici√™ncia m√©dia
}

// üÜï USAR DIRETAMENTE para c√°lculos hist√≥ricos
// ‚ùå N√ÉO criar novas Raw Entities desnecess√°rias
```

### **2.2 Mapeamento Real de Setores**

```mermaid
graph TD
    A[üìÖ Julho: ATIVA<br/>Competi√ß√£o em andamento] --> B[üîÑ 01/08: Autom√°tico]
    B --> C[üìä Julho: PRE_FECHADA]
    B --> D[üìã Agosto: PLANEJAMENTO<br/>üÜï Detectar feriados automaticamente]
    C --> E[üë®‚Äçüíº Diretor confirma fechamento]
    E --> F[‚úÖ Julho: FECHADA]

    D --> G{üéØ Agosto tem feriados?}
    G -->|‚ùå N√£o| I[üë®‚Äçüíº Diretor: Calcular Metas]
    G -->|‚úÖ Sim| H[üö® OBRIGAT√ìRIO: Classificar Feriados<br/>UTIL/SABADO/DOMINGO]
    H --> J[üë®‚Äçüíº Diretor classifica cada feriado]
    J --> I[üë®‚Äçüíº Diretor: Calcular Metas]

    I --> K[üî• EXECUTAR C√ÅLCULOS:<br/>1. KM Prevista<br/>2. Combust√≠vel<br/>3. Pneus + Saldo<br/>4. Pe√ßas + Saldo]
    K --> L[üì± Apresentar resultados na tela]
    L --> M[üë®‚Äçüíº Diretor aprova/rejeita]

    M -->|‚úÖ Aprova| N[üíæ SALVAR em ParameterValueEntity<br/>Mesmo local das outras metas]
    M -->|‚ùå Rejeita| O[‚öôÔ∏è Ajustar par√¢metros]
    O --> K

    N --> P{üéØ Todas as metas definidas?<br/>15 crit√©rios √ó 4 setores}
    P -->|‚ùå N√£o| Q[üë®‚Äçüíº Definir outras metas<br/>Sistema atual]
    P -->|‚úÖ Sim| R[üöÄ Diretor: Iniciar Vig√™ncia]
    Q --> P
    R --> S[üìà Agosto: ATIVA<br/>Competi√ß√£o reinicia]
    S --> T[üîÑ Ciclo continua...]
```

#### **‚ùå CORRE√á√ÉO: Campo erpId N√ÉO EXISTE**

```typescript
// ‚úÖ REALIDADE da SectorEntity:
@Entity({ name: 'sectors' })
export class SectorEntity {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'varchar', length: 255, unique: true })
  nome!: string; // 'GAMA', 'PARANO√Å', etc.

  @Column({ type: 'boolean', default: true })
  ativo!: boolean;

  // ‚ùå N√ÉO TEM: erpId
}

// ‚úÖ SOLU√á√ÉO: Usar mapeamento por nome (como j√° existe no ETL)
export class SectorMappingService {
  private readonly ORACLE_TO_SECTOR_MAPPING = {
    'GARAGEM GAMA': 'GAMA',
    'GARAGEM PARANOA': 'PARANO√Å',
    'GARAGEM SANTA MARIA': 'SANTA MARIA',
    'GARAGEM SAO SEBASTIAO': 'S√ÉO SEBASTI√ÉO',
  };

  async mapOracleToSector(
    oracleGarageName: string
  ): Promise<SectorEntity | null> {
    const sectorName = this.ORACLE_TO_SECTOR_MAPPING[oracleGarageName];
    if (!sectorName) return null;

    return await this.sectorRepo.findOne({ where: { nome: sectorName } });
  }
}
```

### **2.3 Sequ√™ncia de A√ß√µes Detalhada**

```mermaid
sequenceDiagram
    participant S as Sistema
    participant D as Diretor
    participant UI as Interface
    participant API as API
    participant DB as Database
    participant Oracle as Oracle ERP

    Note over S,Oracle: 01/08 - Cria√ß√£o Autom√°tica do Per√≠odo

    S->>DB: Criar per√≠odo Agosto/2025 (PLANEJAMENTO)
    S->>API: Trigger: onPeriodCreated()
    API->>API: Detectar feriados automaticamente
    API->>DB: Salvar feriados n√£o classificados

    Note over D,Oracle: Diretor acessa gest√£o do per√≠odo

    D->>UI: Acessar gest√£o Agosto/2025
    UI->>API: GET /periods/agosto-2025/status
    API->>DB: Verificar feriados pendentes
    DB-->>API: Lista: 2 feriados n√£o classificados
    API-->>UI: Status: "Feriados pendentes de classifica√ß√£o"

    Note over UI: üö® BLOQUEIO: N√£o pode calcular sem classificar

    D->>UI: Classificar feriado 1: "Dia √ötil"
    D->>UI: Classificar feriado 2: "Domingo"
    D->>UI: Salvar classifica√ß√µes
    UI->>API: POST /operational-goals/periods/123/classify-holidays
    API->>DB: Atualizar classifica√ß√µes
    DB-->>API: Confirma√ß√£o
    API-->>UI: "Todos os feriados classificados"

    Note over UI: ‚úÖ LIBERADO: Pode calcular metas

    D->>UI: Informar pre√ßo combust√≠vel: R$ 4,46
    D->>UI: Clicar "Executar C√°lculo"
    UI->>API: POST /operational-goals/periods/123/calculate

    Note over API,Oracle: Busca dados para c√°lculo

    API->>Oracle: Query KM/Combust√≠vel (m√™s anterior)
    Oracle-->>API: Dados di√°rios por garagem
    API->>DB: Buscar custos hist√≥ricos (Pneus/Pe√ßas)
    DB-->>API: Dados 12 meses PerformanceDataEntity
    API->>DB: Buscar metas anteriores (Sistema Saldo)
    DB-->>API: ParameterValueEntity per√≠odo anterior

    Note over API: Executar algoritmos de c√°lculo

    API->>API: 1. Calcular KM Prevista
    API->>API: 2. Calcular Combust√≠vel
    API->>API: 3. Calcular Pneus + Saldo
    API->>API: 4. Calcular Pe√ßas + Saldo
    API->>DB: Salvar resultado tempor√°rio
    DB-->>API: ID do c√°lculo: 456
    API-->>UI: Resultados detalhados

    Note over UI: Diretor revisa resultados

    D->>UI: Analisar: Gama 45.250L, Santa Maria 62.180L...
    D->>UI: Verificar saldos: Pneus -R$1.200, Pe√ßas R$0
    D->>UI: Clicar "Aprovar e Oficializar"
    UI->>API: POST /operational-goals/calculations/456/approve

    Note over API: Salvar como metas oficiais

    API->>DB: Criar ParameterValueEntity (Combust√≠vel/Gama)
    API->>DB: Criar ParameterValueEntity (Combust√≠vel/Santa Maria)
    API->>DB: Criar ParameterValueEntity (Pneus/Gama)
    API->>DB: [... 12 metas total: 3 crit√©rios √ó 4 setores]
    DB-->>API: 12 metas salvas
    API->>DB: Marcar c√°lculo como APROVADO
    API-->>UI: "12 metas oficializadas com sucesso"

    Note over UI: Outras metas (sistema atual)

    D->>UI: Definir metas dos 12 crit√©rios restantes
    Note over D: [Processo normal do sistema atual]

    Note over UI: Verifica√ß√£o final

    UI->>API: Verificar completude: 15√ó4 = 60 metas
    API->>DB: Contar metas ativas do per√≠odo
    DB-->>API: 60 metas encontradas
    API-->>UI: "Per√≠odo pode ser ativado"

    D->>UI: Clicar "Iniciar Vig√™ncia"
    UI->>API: POST /periods/123/activate
    API->>DB: Status: PLANEJAMENTO ‚Üí ATIVA
    DB-->>API: Confirma√ß√£o
    API-->>UI: "Per√≠odo Agosto/2025 ativo - Competi√ß√£o iniciada"
```

---

## 3. **MAPEAMENTO DE FONTES DE DADOS REAIS**

### **3.1 Dados J√° Dispon√≠veis na API**

| Dado Necess√°rio              | Fonte Real na API          | Status           |
| ---------------------------- | -------------------------- | ---------------- |
| **KM di√°rio por garagem**    | Query Oracle (nova)        | üÜï A implementar |
| **Combust√≠vel di√°rio**       | Query Oracle (nova)        | üÜï A implementar |
| **Custos Pneus (hist√≥rico)** | `PerformanceDataEntity`    | ‚úÖ Dispon√≠vel    |
| **Custos Pe√ßas (hist√≥rico)** | `PerformanceDataEntity`    | ‚úÖ Dispon√≠vel    |
| **Metas anteriores**         | `ParameterValueEntity`     | ‚úÖ Dispon√≠vel    |
| **Gasto real anterior**      | `PerformanceDataEntity`    | ‚úÖ Dispon√≠vel    |
| **Mapeamento Garagens**      | `SectorEntity.nome`        | ‚úÖ Dispon√≠vel    |
| **Feriados**                 | API Brasil + classifica√ß√£o | üÜï A implementar |

### **3.2 Aproveitamento das Raw Entities Existentes**

#### **Para Dados Hist√≥ricos (3-12 meses):**

```typescript
// ‚úÖ USAR: RawOracleFleetPerformanceEntity EXISTENTE
async getHistoricalFuelEfficiency(sectorName: string, monthsBack: number = 3): Promise<HistoricalData[]> {
  return await this.rawFleetPerformanceRepo.find({
    where: {
      sectorName,
      metricMonth: Between(startMonth, endMonth)
    },
    order: { metricMonth: 'ASC' }
  });
}

// ‚úÖ USAR: PerformanceDataEntity EXISTENTE
async getHistoricalCosts(criterionName: 'PNEUS' | 'PE√áAS', monthsBack: number = 12): Promise<CostData[]> {
  const criterion = await this.criterionRepo.findOne({ where: { nome: criterionName } });

  return await this.performanceDataRepo.find({
    where: {
      criterionId: criterion.id,
      metricDate: Between(startDate, endDate)
    },
    relations: ['setor']
  });
}
```

### **3.3 Query Oracle Real - Integrada ao ETL Existente**

```typescript
// üÜï ESTENDER OracleEtlService EXISTENTE:
export class OperationalGoalsOracleService extends OracleEtlService {
  async fetchDailyKmAndFuelForGoals(
    startDate: string,
    endDate: string
  ): Promise<OracleKmFuelData[]> {
    // ‚úÖ Usar conex√£o Oracle existente
    const query = `
      SELECT
        A.NOMEGA,
        ROUND(A.QNTCOMB, 2) AS QNTCOMB,        
        A.KM,
        ROUND((A.KM / A.QNTCOMB), 2) AS KMLITRO,
        A.DATAABASTCARRO
      FROM (
        SELECT
          B.NOMEGA,
          B.DATAABASTCARRO,
          SUM(B.QNTCOMB) AS QNTCOMB,        
          SUM(B.KM) AS KM
        FROM (
          SELECT
            G.NOMEGA,
            C.DATAABASTCARRO,
            C.QTDECOMB AS QNTCOMB,        
            K.KMPERCORRIDOVELOC AS KM
          FROM VWABA_CONFKMCARRO K,
               FRT_CADVEICULOS V,
               VWABA_CONSCOMBREPVEIC C,
               CTR_GARAGEM G
          WHERE V.CODIGOVEIC = K.CODIGOVEIC
            AND V.CODIGOGA = G.CODIGOGA
            AND C.CODIGOVEIC = K.CODIGOVEIC
            AND K.DATAVELOC = C.DATAABASTCARRO
            AND C.SEQUENCIAABASTCARRO = K.SEQUENCIAVELOC    
            AND C.DATAABASTCARRO BETWEEN ? AND ?
            AND V.CODIGOEMPRESA = 4
            AND V.CODIGOGA BETWEEN 1 AND 9999
        ) B
        GROUP BY B.NOMEGA, B.DATAABASTCARRO
      ) A
      ORDER BY A.NOMEGA, A.DATAABASTCARRO ASC
    `;

    // ‚úÖ Usar DataSource Oracle existente
    return await this.oracleDataSource.query(query, [startDate, endDate]);
  }
}
```

### **3.4 Fluxo de Dados Detalhado**

```mermaid
graph LR
    subgraph "üè¢ ORACLE ERP"
        O1[VWABA_CONFKMCARRO<br/>KM por ve√≠culo/dia]
        O2[VWABA_CONSCOMBREPVEIC<br/>Combust√≠vel por dia]
        O3[CTR_GARAGEM<br/>Cadastro garagens]
        O4[Dados Hist√≥ricos<br/>3-12 meses]
    end

    subgraph "üåê APIS EXTERNAS"
        E1[Brasil API<br/>Feriados nacionais]
        E2[Feriados Estaduais/Municipais<br/>Bras√≠lia-DF]
    end

    subgraph "üíæ BANCO APLICA√á√ÉO"
        A1[PerformanceDataEntity<br/>Custos Pneus/Pe√ßas]
        A2[ParameterValueEntity<br/>Metas anteriores]
        A3[SectorEntity<br/>Setores ativos]
        A4[CriterionEntity<br/>Crit√©rios]
        A5[CompetitionPeriodEntity<br/>Per√≠odos]
    end

    subgraph "üßÆ MOTOR DE C√ÅLCULO"
        C1[KM Prevista]
        C2[Combust√≠vel]
        C3[Pneus + Saldo]
        C4[Pe√ßas + Saldo]
    end

    subgraph "üíæ RESULTADO"
        R1[ParameterValueEntity<br/>12 metas novas]
        R2[OperationalGoalsCalculationEntity<br/>Auditoria c√°lculo]
        R3[HolidayClassificationEntity<br/>Feriados classificados]
    end

    O1 --> C1
    O2 --> C2
    O3 --> C1
    O4 --> C2
    O4 --> C3
    O4 --> C4

    E1 --> R3
    E2 --> R3

    A1 --> C3
    A1 --> C4
    A2 --> C3
    A2 --> C4
    A3 --> C1
    A4 --> C2
    A5 --> C1

    C1 --> C2
    C1 --> C3
    C1 --> C4

    C2 --> R1
    C3 --> R1
    C4 --> R1

    R3 --> C1
```

---

## 4. **ALGORITMOS DE C√ÅLCULO**

### **4.1 Servi√ßo Principal de C√°lculo**

```typescript
export class OperationalGoalsCalculationService {
  constructor(
    // ‚úÖ Aproveitar servi√ßos existentes
    private oracleEtlService: OracleEtlService,
    private parameterService: ParameterService,
    private performanceDataRepo: Repository<PerformanceDataEntity>,
    private sectorMappingService: SectorMappingService,

    // üÜï Apenas servi√ßos espec√≠ficos novos
    private holidayService: HolidayManagementService,
    private operationalOracleService: OperationalGoalsOracleService
  ) {}

  async executeFullCalculation(
    competitionPeriodId: number,
    userId: number
  ): Promise<CalculationResult> {
    // 1. Validar pr√©-requisitos usando estruturas existentes
    await this.validatePrerequisites(competitionPeriodId);

    // 2. Buscar setores ativos (entidade existente)
    const activeSectors = await this.sectorRepo.find({
      where: { ativo: true },
    });

    // 3. Executar c√°lculos para cada setor
    const results = {};

    for (const sector of activeSectors) {
      // KM Prevista
      const kmResult = await this.calculateKmPrevista(
        competitionPeriodId,
        sector
      );

      // Combust√≠vel (usando Raw Data existente)
      const combustivelResult = await this.calculateCombustivel(
        kmResult,
        sector
      );

      // Pneus (usando PerformanceDataEntity existente)
      const pneusResult = await this.calculatePneusPecas(
        kmResult,
        sector,
        'PNEUS'
      );

      // Pe√ßas (usando PerformanceDataEntity existente)
      const pecasResult = await this.calculatePneusPecas(
        kmResult,
        sector,
        'PE√áAS'
      );

      results[sector.id] = {
        kmPrevista: kmResult,
        combustivel: combustivelResult,
        pneus: pneusResult,
        pecas: pecasResult,
      };
    }

    return {
      competitionPeriodId,
      results,
      calculatedAt: new Date(),
      calculatedBy: userId,
    };
  }

  private async calculateKmPrevista(
    competitionPeriodId: number,
    sector: SectorEntity
  ): Promise<KmPrevistaResult> {
    // 1. Buscar per√≠odo para determinar m√™s de refer√™ncia
    const period = await this.periodRepo.findOne({
      where: { id: competitionPeriodId },
    });
    const referenceMonth = this.getPreviousMonth(period.mesAno);

    // 2. Buscar dados Oracle usando servi√ßo estendido
    const oracleData =
      await this.operationalOracleService.fetchDailyKmAndFuelForGoals(
        `${referenceMonth}-01`,
        `${referenceMonth}-31`
      );

    // 3. Filtrar dados do setor usando mapeamento real
    const sectorData = oracleData.filter((d) => {
      const mappedSector = this.sectorMappingService.mapOracleToSectorSync(
        d.NOMEGA
      );
      return mappedSector?.id === sector.id;
    });

    // 4. Analisar padr√µes e projetar
    const averages = this.analyzeDailyPatterns(sectorData);
    const projection = await this.projectFutureMonth(
      averages,
      period.mesAno,
      competitionPeriodId
    );

    return {
      sectorId: sector.id,
      sectorName: sector.nome,
      projectedKm: projection.totalKm,
      calculationDetails: {
        referenceMonth,
        dailyAverages: averages,
        futureCalendar: projection.calendar,
      },
    };
  }

  private async calculateCombustivel(
    kmResult: KmPrevistaResult,
    sector: SectorEntity
  ): Promise<CombustivelResult> {
    // ‚úÖ Usar Raw Data existente para hist√≥rico
    const historical = await this.rawFleetPerformanceRepo.find({
      where: {
        sectorName: sector.nome,
        metricMonth: Between(this.getMonthsAgo(3), this.getLastMonth()),
      },
    });

    // Calcular m√©dia de efici√™ncia
    const totalKm = historical.reduce((sum, month) => sum + month.totalKm, 0);
    const totalLiters = historical.reduce(
      (sum, month) => sum + month.totalFuelLiters,
      0
    );
    const avgKmPerLiter = totalKm / totalLiters;

    // Buscar par√¢metro de redu√ß√£o
    const fatorReducao = await this.getOperationalParameter(
      'FATOR_REDUCAO_COMBUSTIVEL'
    );

    // Calcular meta
    const litrosPrevistoBruto = kmResult.projectedKm / avgKmPerLiter;
    const metaLitros = litrosPrevistoBruto * (1 - fatorReducao);

    return {
      sectorId: sector.id,
      kmPrevista: kmResult.projectedKm,
      historical3Months: {
        totalKm,
        totalLiters,
        avgKmPerLiter,
      },
      fatorReducao,
      metaLitros,
      calculationDetails: {
        litrosPrevistoBruto,
        reductionApplied: litrosPrevistoBruto * fatorReducao,
      },
    };
  }

  private async calculatePneusPecas(
    kmResult: KmPrevistaResult,
    sector: SectorEntity,
    criterionType: 'PNEUS' | 'PE√áAS'
  ): Promise<PneusPecasResult> {
    // ‚úÖ Usar PerformanceDataEntity existente para custos hist√≥ricos
    const criterion = await this.criterionRepo.findOne({
      where: { nome: criterionType },
    });
    const historicalCosts = await this.performanceDataRepo.find({
      where: {
        criterionId: criterion.id,
        sectorId: sector.id,
        metricDate: Between(this.getMonthsAgo(12), this.getLastMonth()),
      },
    });

    // Calcular custo m√©dio por KM
    const totalCost12M = historicalCosts.reduce(
      (sum, month) => sum + (month.valor || 0),
      0
    );
    const totalKm12M = await this.getTotalKmFor12Months(sector.id);
    const avgCostPerKm = totalCost12M / totalKm12M;

    // Calcular meta base
    const custoPrevistoKm = kmResult.projectedKm * avgCostPerKm;
    const percentualPremiacao = await this.getOperationalParameter(
      `PERCENTUAL_PREMIACAO_${criterionType}`
    );
    const metaBase = custoPrevistoKm * (1 - percentualPremiacao);

    // Calcular saldo devedor usando ParameterValueEntity existente
    const saldoDevedor = await this.calculateSaldoDevedor(
      sector.id,
      criterionType,
      kmResult.competitionPeriodId
    );

    return {
      sectorId: sector.id,
      criterionType,
      kmPrevista: kmResult.projectedKm,
      annualCostData: {
        totalKm12Months: totalKm12M,
        totalCost12Months: totalCost12M,
        avgCostPerKm,
      },
      metaBase,
      saldoDevedor,
      metaFinal: metaBase - saldoDevedor,
      calculationDetails: {
        custoPrevistoKm,
        percentualPremiacao,
        reductionApplied: custoPrevistoKm * percentualPremiacao,
      },
    };
  }

  private async calculateSaldoDevedor(
    sectorId: number,
    criterionType: 'PNEUS' | 'PE√áAS',
    currentPeriodId: number
  ): Promise<number> {
    // ‚úÖ Buscar meta anterior usando ParameterValueEntity existente
    const previousPeriod = await this.getPreviousPeriod(currentPeriodId);
    if (!previousPeriod) return 0;

    const criterion = await this.criterionRepo.findOne({
      where: { nome: criterionType },
    });

    const metaAnterior = await this.parameterRepo.findOne({
      where: {
        competitionPeriodId: previousPeriod.id,
        sectorId,
        criterionId: criterion.id,
        dataFimEfetivo: IsNull(),
      },
    });

    // ‚úÖ Buscar gasto real usando PerformanceDataEntity existente
    const gastoReal = await this.performanceDataRepo.findOne({
      where: {
        competitionPeriodId: previousPeriod.id,
        sectorId,
        criterionId: criterion.id,
      },
    });

    if (!metaAnterior || !gastoReal) return 0;

    // Calcular saldo
    const metaAprovada = parseFloat(metaAnterior.valor);
    const gastoRealizado = gastoReal.valor || 0;
    const tolerancia = await this.getOperationalParameter(
      'PERCENTUAL_TOLERANCIA_SALDO'
    );
    const tetoGasto = metaAprovada * (1 + tolerancia);

    return gastoRealizado > tetoGasto ? gastoRealizado - tetoGasto : 0;
  }
}
```

---

## 5. **IMPLEMENTA√á√ÉO BASEADA NA API REAL**

### **5.1 Novas Entidades Necess√°rias (M√≠nimas)**

```typescript
// üÜï √öNICA entidade nova realmente necess√°ria para feriados
@Entity('holiday_classifications')
export class HolidayClassificationEntity {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column('date')
  holidayDate!: string;

  @Column('varchar', { length: 100 })
  holidayName!: string;

  @Column({
    type: 'varchar',
    enum: ['UTIL', 'SABADO', 'DOMINGO_FERIADO'],
  })
  classification!: 'UTIL' | 'SABADO' | 'DOMINGO_FERIADO';

  @Column()
  competitionPeriodId!: number;

  @ManyToOne(() => CompetitionPeriodEntity, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'competitionPeriodId' })
  competitionPeriod!: CompetitionPeriodEntity;

  @Column()
  classifiedBy!: number;

  @CreateDateColumn()
  classifiedAt!: Date;
}

// üÜï Para par√¢metros de configura√ß√£o globais (separados das metas)
@Entity('operational_goals_parameters')
export class OperationalGoalsParametersEntity {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column('varchar', { length: 100, unique: true })
  parameterName!: string; // 'FATOR_REDUCAO_COMBUSTIVEL'

  @Column('decimal', { precision: 10, scale: 6 })
  value!: number; // 0.015

  @Column('text')
  description!: string;

  @Column('text', { nullable: true })
  changeJustification?: string;

  @UpdateDateColumn()
  updatedAt!: Date;

  @Column()
  updatedBy!: number;
}

// üÜï Para armazenar resultados tempor√°rios de c√°lculo (antes da aprova√ß√£o)
@Entity('operational_goals_calculations')
export class OperationalGoalsCalculationEntity {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  competitionPeriodId!: number;

  @Column('jsonb')
  calculationData!: any; // Resultados completos

  @Column({
    type: 'varchar',
    enum: ['PENDING', 'COMPLETED', 'APPROVED', 'REJECTED'],
    default: 'COMPLETED',
  })
  status!: string;

  @Column()
  calculatedBy!: number;

  @CreateDateColumn()
  calculatedAt!: Date;

  @Column({ nullable: true })
  approvedBy?: number;

  @Column({ type: 'timestamp with time zone', nullable: true })
  approvedAt?: Date;
}
```

### **5.2 Extens√£o de Servi√ßos Existentes**

```typescript
// ‚úÖ ESTENDER ParameterService EXISTENTE (n√£o substituir)
export class ParameterService {
  // ... todos os m√©todos existentes ...

  /**
   * üÜï M√©todo espec√≠fico para salvar metas operacionais
   */
  async saveOperationalGoalsMetas(
    calculationId: number,
    userId: number
  ): Promise<ParameterValueEntity[]> {
    const calculation = await this.calculationRepo.findOne({
      where: { id: calculationId },
    });
    const savedParameters: ParameterValueEntity[] = [];

    // ‚úÖ Usar createParameter() EXISTENTE
    for (const [sectorId, results] of Object.entries(
      calculation.calculationData
    )) {
      // COMBUST√çVEL
      const combustivelParam = await this.createParameter(
        {
          criterionId: await this.getCriterionId('COMBUST√çVEL'),
          sectorId: parseInt(sectorId),
          competitionPeriodId: calculation.competitionPeriodId,
          valor: results.combustivel.metaLitros.toString(),
          dataInicioEfetivo: calculation.period.dataInicio,
          justificativa: `Meta autom√°tica operacional - C√°lculo ID: ${calculationId}`,
          metadata: {
            calculationId,
            isOperationalGoal: true,
            algorithm: 'operational_goals_v2.0',
          },
        },
        await this.getUserById(userId)
      );

      savedParameters.push(combustivelParam);

      // PNEUS e PE√áAS seguem mesmo padr√£o...
    }

    return savedParameters;
  }
}

// üÜï NOVO servi√ßo espec√≠fico para feriados
export class HolidayManagementService {
  async detectHolidaysForPeriod(
    competitionPeriodId: number
  ): Promise<Holiday[]> {
    const period = await this.periodRepo.findOne({
      where: { id: competitionPeriodId },
    });
    const [year, month] = period.mesAno.split('-');

    // Buscar na API Brasil
    const holidays = await this.fetchHolidaysFromBrasilAPI(year, month);

    // Salvar como n√£o classificados
    for (const holiday of holidays) {
      await this.holidayRepo.save({
        holidayDate: holiday.date,
        holidayName: holiday.name,
        competitionPeriodId,
        classification: null, // Aguardando classifica√ß√£o
      });
    }

    return holidays;
  }

  async requiresClassification(competitionPeriodId: number): Promise<boolean> {
    const unclassified = await this.holidayRepo.count({
      where: {
        competitionPeriodId,
        classification: IsNull(),
      },
    });

    return unclassified > 0;
  }
}
```

### **5.3 Integra√ß√£o com Workflow Existente**

```typescript
// ‚úÖ USAR CompetitionPeriodService EXISTENTE
export class CompetitionPeriodService {
  // ... m√©todos existentes ...

  /**
   * üÜï Hook para detec√ß√£o autom√°tica de feriados
   */
  async onPeriodCreated(newPeriod: CompetitionPeriodEntity): Promise<void> {
    if (newPeriod.status === 'PLANEJAMENTO') {
      // üÜï Detectar feriados automaticamente
      await this.holidayService.detectHolidaysForPeriod(newPeriod.id);
    }
  }

  /**
   * ‚úÖ ESTENDER valida√ß√£o existente
   */
  async canActivatePeriod(
    competitionPeriodId: number
  ): Promise<ValidationResult> {
    // ‚úÖ Valida√ß√£o existente (todas as metas definidas)
    const baseValidation =
      await this.validateAllGoalsDefined(competitionPeriodId);

    if (!baseValidation.canActivate) {
      return baseValidation;
    }

    // üÜï Valida√ß√£o adicional (feriados classificados se houver)
    const hasUnclassifiedHolidays =
      await this.holidayService.requiresClassification(competitionPeriodId);

    if (hasUnclassifiedHolidays) {
      return {
        canActivate: false,
        message: 'Existem feriados n√£o classificados para este per√≠odo',
      };
    }

    return baseValidation;
  }
}
```

---

## 6. **APIs E ENDPOINTS**

### **6.1 Rotas Espec√≠ficas Novas**

```typescript
// apps/api/src/routes/operational-goals.routes.ts
const operationalGoalsRoutes: FastifyPluginAsync = async (fastify) => {
  /**
   * GET /api/operational-goals/periods/:periodId/holidays-status
   * Verificar status de feriados
   */
  fastify.get<{ Params: { periodId: string } }>(
    '/api/operational-goals/periods/:periodId/holidays-status',
    {
      preHandler: [fastify.authenticate],
      schema: {
        description: 'Verificar status de classifica√ß√£o de feriados',
        tags: ['Operational Goals'],
      },
    },
    async (request, reply) => {
      const periodId = parseInt(request.params.periodId);

      const holidays =
        await fastify.services.holidayManagement.getHolidaysForPeriod(periodId);
      const hasUnclassified =
        await fastify.services.holidayManagement.requiresClassification(
          periodId
        );

      return {
        hasUnclassifiedHolidays: hasUnclassified,
        holidays: holidays.map((h) => ({
          date: h.holidayDate,
          name: h.holidayName,
          isClassified: !!h.classification,
          classification: h.classification,
        })),
      };
    }
  );

  /**
   * POST /api/operational-goals/periods/:periodId/classify-holidays
   * Classificar feriados (somente diretores)
   */
  fastify.post<{
    Params: { periodId: string };
    Body: { classifications: Array<{ date: string; classification: string }> };
  }>(
    '/api/operational-goals/periods/:periodId/classify-holidays',
    {
      preHandler: [fastify.authenticate, requireDirectorRole],
      schema: {
        description: 'Classificar feriados (somente diretores)',
        tags: ['Operational Goals'],
      },
    },
    async (request, reply) => {
      const periodId = parseInt(request.params.periodId);
      const { classifications } = request.body;
      const userId = request.user.id;
      await fastify.services.holidayManagement.saveClassifications(
        periodId,
        classifications,
        userId
      );

      return {
        success: true,
        message: 'Feriados classificados com sucesso',
      };
    }
  );

  /**
   * POST /api/operational-goals/periods/:periodId/calculate
   * Executar c√°lculo autom√°tico (somente diretores)
   */
  fastify.post<{
    Params: { periodId: string };
    Body: { precoCombustivel?: number };
  }>(
    '/api/operational-goals/periods/:periodId/calculate',
    {
      preHandler: [fastify.authenticate, requireDirectorRole],
      schema: {
        description: 'Executar c√°lculo autom√°tico de metas',
        tags: ['Operational Goals'],
      },
    },
    async (request, reply) => {
      const periodId = parseInt(request.params.periodId);
      const userId = request.user.id;
      const { precoCombustivel } = request.body;

      try {
        const calculation =
          await fastify.services.operationalGoalsCalculation.executeFullCalculation(
            periodId,
            userId
          );

        // Aplicar pre√ßo do combust√≠vel se fornecido
        if (precoCombustivel) {
          calculation.fuelPriceUsed = precoCombustivel;
          // Recalcular proje√ß√µes financeiras
          for (const sectorResult of Object.values(calculation.results)) {
            sectorResult.combustivel.metaReais =
              sectorResult.combustivel.metaLitros * precoCombustivel;
          }
        }

        return {
          calculationId: calculation.id,
          status: 'COMPLETED',
          results: calculation.results,
          summary: {
            sectorsProcessed: Object.keys(calculation.results).length,
            criteriaCalculated: ['COMBUST√çVEL', 'PNEUS', 'PE√áAS'],
            calculatedAt: calculation.calculatedAt,
          },
        };
      } catch (error) {
        if (error.message === 'HOLIDAYS_NOT_CLASSIFIED') {
          return reply.status(400).send({
            error: 'Feriados n√£o classificados',
            code: 'HOLIDAYS_NOT_CLASSIFIED',
          });
        }

        if (error.message === 'PERIOD_NOT_IN_PLANNING') {
          return reply.status(400).send({
            error: 'Per√≠odo n√£o est√° em planejamento',
            code: 'PERIOD_NOT_IN_PLANNING',
          });
        }

        throw error;
      }
    }
  );

  /**
   * POST /api/operational-goals/calculations/:calculationId/approve
   * Aprovar e oficializar metas (somente diretores)
   */
  fastify.post<{
    Params: { calculationId: string };
    Body: { observations?: string };
  }>(
    '/api/operational-goals/calculations/:calculationId/approve',
    {
      preHandler: [fastify.authenticate, requireDirectorRole],
      schema: {
        description: 'Aprovar c√°lculo e oficializar como metas',
        tags: ['Operational Goals'],
      },
    },
    async (request, reply) => {
      const calculationId = parseInt(request.params.calculationId);
      const userId = request.user.id;
      const { observations } = request.body;

      // ‚úÖ Usar ParameterService EXISTENTE para salvar metas
      const savedParameters =
        await fastify.services.parameter.saveOperationalGoalsMetas(
          calculationId,
          userId
        );

      // Marcar c√°lculo como aprovado
      await fastify.services.operationalGoalsCalculation.approveCalculation(
        calculationId,
        userId,
        observations
      );

      return {
        success: true,
        message: 'Metas aprovadas e oficializadas no sistema',
        savedGoals: savedParameters.length,
        details: savedParameters.map((param) => ({
          criterion: param.criterion?.nome,
          sector: param.setor?.nome,
          value: param.valor,
          effectiveDate: param.dataInicioEfetivo,
        })),
      };
    }
  );

  /**
   * GET /api/operational-goals/parameters
   * Buscar par√¢metros configur√°veis
   */
  fastify.get(
    '/api/operational-goals/parameters',
    {
      preHandler: [fastify.authenticate],
      schema: {
        description: 'Buscar par√¢metros configur√°veis do sistema',
        tags: ['Operational Goals - Parameters'],
      },
    },
    async (request, reply) => {
      const parameters =
        await fastify.services.operationalGoalsParameters.getAllParameters();

      return {
        parameters: parameters.reduce((acc, param) => {
          acc[param.parameterName] = {
            value: param.value,
            description: param.description,
            lastUpdated: param.updatedAt,
            updatedBy: param.updatedByUser?.nome,
          };
          return acc;
        }, {}),
        lastCheck: new Date().toISOString(),
      };
    }
  );

  /**
   * PUT /api/operational-goals/parameters/:parameterName
   * Atualizar par√¢metro (somente diretores)
   */
  fastify.put<{
    Params: { parameterName: string };
    Body: { value: number; justification: string };
  }>(
    '/api/operational-goals/parameters/:parameterName',
    {
      preHandler: [fastify.authenticate, requireDirectorRole],
      schema: {
        description: 'Atualizar par√¢metro de c√°lculo',
        tags: ['Operational Goals - Parameters'],
        body: {
          type: 'object',
          properties: {
            value: { type: 'number', minimum: 0, maximum: 1 },
            justification: { type: 'string', minLength: 10, maxLength: 500 },
          },
          required: ['value', 'justification'],
        },
      },
    },
    async (request, reply) => {
      const { parameterName } = request.params;
      const { value, justification } = request.body;
      const userId = request.user.id;

      const updatedParameter =
        await fastify.services.operationalGoalsParameters.updateParameter(
          parameterName,
          value,
          justification,
          userId
        );

      // ‚úÖ Auditoria usando sistema existente
      await fastify.services.auditLog.createLog({
        userId,
        userName: request.user.nome,
        actionType: 'OPERATIONAL_PARAMETER_UPDATED',
        entityType: 'OperationalGoalsParametersEntity',
        entityId: updatedParameter.id.toString(),
        details: {
          parameterName,
          previousValue: updatedParameter.previousValue,
          newValue: value,
          justification,
        },
        justification,
      });

      return {
        success: true,
        parameter: {
          name: updatedParameter.parameterName,
          value: updatedParameter.value,
          description: updatedParameter.description,
          updatedAt: updatedParameter.updatedAt,
        },
      };
    }
  );

  /**
   * GET /api/operational-goals/calculations/:calculationId
   * Buscar detalhes de c√°lculo espec√≠fico
   */
  fastify.get<{ Params: { calculationId: string } }>(
    '/api/operational-goals/calculations/:calculationId',
    {
      preHandler: [fastify.authenticate],
      schema: {
        description: 'Buscar detalhes de c√°lculo espec√≠fico',
        tags: ['Operational Goals'],
      },
    },
    async (request, reply) => {
      const calculationId = parseInt(request.params.calculationId);

      const calculation =
        await fastify.services.operationalGoalsCalculation.getCalculationDetails(
          calculationId
        );

      if (!calculation) {
        return reply.status(404).send({
          error: 'C√°lculo n√£o encontrado',
        });
      }

      return calculation;
    }
  );

  fastify.log.info('‚úÖ Rotas de Metas Operacionais registradas');
};

export default fp(operationalGoalsRoutes, {
  name: 'operational-goals-routes',
});
```

### **6.2 Integra√ß√£o com Sistema de Servi√ßos Existente**

```typescript
// apps/api/src/plugins/services.ts - ATUALIZADO
import { OperationalGoalsCalculationService } from '@/modules/operational-goals/calculation.service';
import { HolidayManagementService } from '@/modules/operational-goals/holiday.service';
import { OperationalGoalsParametersService } from '@/modules/operational-goals/parameters.service';

interface Services {
  // ‚úÖ Servi√ßos existentes
  ranking: RankingService;
  parameter: ParameterService;
  auditLog: AuditLogService;
  expurgo: ExpurgoService;
  competitionPeriod: CompetitionPeriodService;
  history: HistoryService;
  auth: AuthService;
  user: UserService;

  // üÜï Novos servi√ßos espec√≠ficos
  operationalGoalsCalculation: OperationalGoalsCalculationService;
  holidayManagement: HolidayManagementService;
  operationalGoalsParameters: OperationalGoalsParametersService;
}

const servicesPlugin: FastifyPluginAsync = async (fastify: FastifyInstance) => {
  const services: Services = {
    // ‚úÖ Inst√¢ncias existentes
    ranking: new RankingService(),
    parameter: new ParameterService(),
    auditLog: new AuditLogService(),
    expurgo: new ExpurgoService(),
    competitionPeriod: new CompetitionPeriodService(),
    history: new HistoryService(),
    auth: new AuthService(),
    user: new UserService(),

    // üÜï Novas inst√¢ncias
    operationalGoalsCalculation: new OperationalGoalsCalculationService(),
    holidayManagement: new HolidayManagementService(),
    operationalGoalsParameters: new OperationalGoalsParametersService(),
  };

  fastify.decorate('services', services);

  fastify.log.info('‚úÖ Todos os servi√ßos registrados via dependency injection');
};
```

---

## 7. **INTERFACE GERENCIAL**

### **7.1 Integra√ß√£o com Tela de Gest√£o de Per√≠odos Existente**

```typescript
// Aproveitar estrutura existente da tela de per√≠odos
function PlanningPeriodManagement({ period }: { period: CompetitionPeriodEntity }) {
  const [holidaysStatus, setHolidaysStatus] = useState<HolidaysStatus>();
  const [calculationResult, setCalculationResult] = useState<CalculationResult>();
  const [parameters, setParameters] = useState<OperationalParameters>();

  // ‚úÖ Usar hooks existentes onde poss√≠vel
  const { parameters: currentGoals } = useParameters(period.mesAno);
  const { canActivate } = usePeriodValidation(period.id);

  return (
    <div className="period-management-container">

      {/* ‚úÖ SE√á√ïES EXISTENTES continuam iguais */}
      <PeriodStatusCard period={period} />

      {/* üÜï NOVA SE√á√ÉO: Classifica√ß√£o de Feriados */}
      {period.status === 'PLANEJAMENTO' && (
        <HolidayClassificationSection
          period={period}
          holidaysStatus={holidaysStatus}
          onClassificationComplete={() => setHolidaysStatus({...holidaysStatus, allClassified: true})}
        />
      )}

      {/* üÜï NOVA SE√á√ÉO: C√°lculo de Metas Operacionais */}
      {period.status === 'PLANEJAMENTO' && holidaysStatus?.allClassified && (
        <OperationalGoalsCalculationSection
          period={period}
          onCalculationComplete={setCalculationResult}
          onGoalsApproved={handleGoalsApproved}
        />
      )}

      {/* ‚úÖ SE√á√ÉO EXISTENTE: Outras Metas (12 crit√©rios) */}
      <OtherGoalsSection
        period={period}
        existingGoals={currentGoals}
        excludeCriteria={['COMBUST√çVEL', 'PNEUS', 'PE√áAS']} // üÜï Excluir os 3 autom√°ticos
      />

      {/* ‚úÖ SE√á√ÉO EXISTENTE: Ativa√ß√£o do Per√≠odo */}
      <PeriodActivationSection
        period={period}
        canActivate={canActivate}
        totalGoalsRequired={60} // 15 crit√©rios √ó 4 setores
        currentGoalsDefined={getCurrentGoalsCount()}
      />

    </div>
  );
}

// üÜï Componente espec√≠fico para classifica√ß√£o de feriados
function HolidayClassificationSection({
  period,
  holidaysStatus,
  onClassificationComplete
}: HolidayClassificationSectionProps) {

  const [classifications, setClassifications] = useState<HolidayClassification[]>([]);
  const [isSaving, setIsSaving] = useState(false);

  const handleClassifyHoliday = (holidayDate: string, classification: string) => {
    setClassifications(prev =>
      prev.map(item =>
        item.date === holidayDate
          ? { ...item, classification }
          : item
      )
    );
  };

  const handleSaveClassifications = async () => {
    setIsSaving(true);

    try {
      await api.post(`/operational-goals/periods/${period.id}/classify-holidays`, {
        classifications: classifications.filter(c => c.classification)
      });

      toast.success('Feriados classificados com sucesso!');
      onClassificationComplete();

    } catch (error) {
      toast.error('Erro ao salvar classifica√ß√µes');
    } finally {
      setIsSaving(false);
    }
  };

  if (!holidaysStatus?.hasUnclassifiedHolidays) {
    return (
      <Card className="mb-6">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <CheckCircle className="text-green-500" />
            Feriados Classificados
          </CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-gray-600">
            Todos os feriados de {period.mesAno} foram classificados.
          </p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="mb-6 border-amber-200 bg-amber-50">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <AlertTriangle className="text-amber-500" />
          Classifica√ß√£o de Feriados Obrigat√≥ria
        </CardTitle>
        <CardDescription>
          Para calcular as metas operacionais, classifique os feriados de {period.mesAno} conforme opera√ß√£o planejada.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {holidaysStatus.holidays.filter(h => !h.isClassified).map(holiday => (
            <div key={holiday.date} className="flex items-center justify-between p-3 border rounded-lg">
              <div>
                <div className="font-medium">{holiday.name}</div>
                <div className="text-sm text-gray-500">{formatDate(holiday.date)}</div>
              </div>
              <RadioGroup
                value={classifications.find(c => c.date === holiday.date)?.classification || ''}
                onValueChange={(value) => handleClassifyHoliday(holiday.date, value)}
                className="flex gap-4"
              >
                <div className="flex items-center space-x-2">
                  <RadioGroupItem value="UTIL" id={`${holiday.date}-util`} />
                  <Label htmlFor={`${holiday.date}-util`}>Dia √ötil</Label>
                </div>
                <div className="flex items-center space-x-2">
                  <RadioGroupItem value="SABADO" id={`${holiday.date}-sabado`} />
                  <Label htmlFor={`${holiday.date}-sabado`}>S√°bado</Label>
                </div>
                <div className="flex items-center space-x-2">
                  <RadioGroupItem value="DOMINGO_FERIADO" id={`${holiday.date}-domingo`} />
                  <Label htmlFor={`${holiday.date}-domingo`}>Domingo</Label>
                </div>
              </RadioGroup>
            </div>
          ))}

          <div className="flex justify-end pt-4">
            <Button
              onClick={handleSaveClassifications}
              disabled={isSaving || !allHolidaysClassified()}
              className="min-w-[150px]"
            >
              {isSaving ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Salvando...
                </>
              ) : (
                <>
                  <Save className="mr-2 h-4 w-4" />
                  Salvar Classifica√ß√µes
                </>
              )}
            </Button>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

// üÜï Componente espec√≠fico para c√°lculo de metas
function OperationalGoalsCalculationSection({
  period,
  onCalculationComplete,
  onGoalsApproved
}: OperationalGoalsCalculationSectionProps) {

  const [fuelPrice, setFuelPrice] = useState<number>(0);
  const [isCalculating, setIsCalculating] = useState(false);
  const [calculationResult, setCalculationResult] = useState<CalculationResult | null>(null);

  const handleExecuteCalculation = async () => {
    setIsCalculating(true);

    try {
      const result = await api.post(`/operational-goals/periods/${period.id}/calculate`, {
        precoCombustivel: fuelPrice || undefined
      });

      setCalculationResult(result.data);
      onCalculationComplete(result.data);

      toast.success('C√°lculo executado com sucesso!');

    } catch (error) {
      if (error.response?.data?.code === 'HOLIDAYS_NOT_CLASSIFIED') {
        toast.error('Classifique todos os feriados antes de calcular');
      } else {
        toast.error('Erro ao executar c√°lculo');
      }
    } finally {
      setIsCalculating(false);
    }
  };

  const handleApproveGoals = async () => {
    if (!calculationResult) return;

    try {
      await api.post(`/operational-goals/calculations/${calculationResult.calculationId}/approve`);

      toast.success('Metas aprovadas e oficializadas!');
      onGoalsApproved();

    } catch (error) {
      toast.error('Erro ao aprovar metas');
    }
  };

  return (
    <Card className="mb-6">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Calculator className="text-blue-500" />
          C√°lculo de Metas Operacionais
        </CardTitle>
        <CardDescription>
          C√°lculo autom√°tico para COMBUST√çVEL, PNEUS e PE√áAS baseado na metodologia oficial.
        </CardDescription>
      </CardHeader>
      <CardContent>

        {/* Input de pre√ßo do combust√≠vel */}
        <div className="mb-4">
          <Label htmlFor="fuel-price">
            Pre√ßo do Combust√≠vel por Litro (opcional - para proje√ß√£o financeira)
          </Label>
          <Input
            id="fuel-price"
            type="number"
            step="0.001"
            placeholder="Ex: 4.462"
            value={fuelPrice || ''}
            onChange={(e) => setFuelPrice(parseFloat(e.target.value) || 0)}
            className="mt-1"
          />
        </div>

        {/* Bot√£o de execu√ß√£o */}
        <div className="mb-4">
          <Button
            onClick={handleExecuteCalculation}
            disabled={isCalculating}
            className="w-full"
            size="lg"
          >
            {isCalculating ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Executando C√°lculos...
              </>
            ) : (
              <>
                <Calculator className="mr-2 h-4 w-4" />
                Executar C√°lculo Autom√°tico
              </>
            )}
          </Button>
        </div>

        {/* Resultados */}
        {calculationResult && (
          <CalculationResultsDisplay
            result={calculationResult}
            onApprove={handleApproveGoals}
            onRecalculate={handleExecuteCalculation}
          />
        )}

      </CardContent>
    </Card>
  );
}
```

### **7.2 Tela de Configura√ß√£o de Par√¢metros**

```typescript
// üÜï Nova p√°gina para configura√ß√£o de par√¢metros
function OperationalGoalsParametersPage() {
  const [parameters, setParameters] = useState<OperationalParameters>();
  const [editingParameter, setEditingParameter] = useState<string | null>(null);

  useEffect(() => {
    loadParameters();
  }, []);

  const loadParameters = async () => {
    try {
      const response = await api.get('/operational-goals/parameters');
      setParameters(response.data.parameters);
    } catch (error) {
      toast.error('Erro ao carregar par√¢metros');
    }
  };

  const handleUpdateParameter = async (
    parameterName: string,
    value: number,
    justification: string
  ) => {
    try {
      await api.put(`/operational-goals/parameters/${parameterName}`, {
        value,
        justification
      });

      toast.success('Par√¢metro atualizado com sucesso');
      await loadParameters();
      setEditingParameter(null);

    } catch (error) {
      toast.error('Erro ao atualizar par√¢metro');
    }
  };

  return (
    <div className="max-w-4xl mx-auto p-6">
      <PageHeader
        title="Configura√ß√£o de Par√¢metros"
        description="Ajuste os percentuais utilizados no c√°lculo autom√°tico de metas operacionais"
      />

      <div className="grid gap-6 mt-6">

        <ParameterCard
          title="Combust√≠vel - Fator de Redu√ß√£o"
          description="Percentual de redu√ß√£o aplicado sobre a previs√£o bruta de consumo"
          parameterName="FATOR_REDUCAO_COMBUSTIVEL"
          currentValue={parameters?.FATOR_REDUCAO_COMBUSTIVEL}
          format="percentage"
          example="1.5% = meta ser√° 1.5% menor que a previs√£o baseada no hist√≥rico"
          onUpdate={handleUpdateParameter}
          isEditing={editingParameter === 'FATOR_REDUCAO_COMBUSTIVEL'}
          onStartEdit={() => setEditingParameter('FATOR_REDUCAO_COMBUSTIVEL')}
          onCancelEdit={() => setEditingParameter(null)}
        />

        <ParameterCard
          title="Pneus - Percentual de Premia√ß√£o"
          description="Desconto aplicado na meta base como incentivo de efici√™ncia"
          parameterName="PERCENTUAL_PREMIACAO_PNEUS"
          currentValue={parameters?.PERCENTUAL_PREMIACAO_PNEUS}
          format="percentage"
          example="3% = meta ser√° 3% menor que o custo previsto baseado no hist√≥rico"
          onUpdate={handleUpdateParameter}
          isEditing={editingParameter === 'PERCENTUAL_PREMIACAO_PNEUS'}
          onStartEdit={() => setEditingParameter('PERCENTUAL_PREMIACAO_PNEUS')}
          onCancelEdit={() => setEditingParameter(null)}
        />

        <ParameterCard
          title="Pe√ßas - Percentual de Premia√ß√£o"
          description="Desconto aplicado na meta base como incentivo de efici√™ncia"
          parameterName="PERCENTUAL_PREMIACAO_PECAS"
          currentValue={parameters?.PERCENTUAL_PREMIACAO_PECAS}
          format="percentage"
          example="3% = meta ser√° 3% menor que o custo previsto baseado no hist√≥rico"
          onUpdate={handleUpdateParameter}
          isEditing={editingParameter === 'PERCENTUAL_PREMIACAO_PECAS'}
          onStartEdit={() => setEditingParameter('PERCENTUAL_PREMIACAO_PECAS')}
          onCancelEdit={() => setEditingParameter(null)}
        />

        <ParameterCard
          title="Sistema de Saldo - Toler√¢ncia"
          description="Toler√¢ncia sobre a meta antes de gerar saldo devedor para o pr√≥ximo m√™s"
          parameterName="PERCENTUAL_TOLERANCIA_SALDO"
          currentValue={parameters?.PERCENTUAL_TOLERANCIA_SALDO}
          format="percentage"
          example="8% = gasto at√© 8% acima da meta n√£o gera saldo devedor"
          onUpdate={handleUpdateParameter}
          isEditing={editingParameter === 'PERCENTUAL_TOLERANCIA_SALDO'}
          onStartEdit={() => setEditingParameter('PERCENTUAL_TOLERANCIA_SALDO')}
          onCancelEdit={() => setEditingParameter(null)}
        />

      </div>
    </div>
  );
}
```

---

## 8. **CRONOGRAMA DE IMPLEMENTA√á√ÉO CORRIGIDO**

### **üöÄ Sprint 1: Funda√ß√£o com Infraestrutura Existente (Semanas 1-2)**

#### **Objetivos:**

- Aproveitar m√°ximo da infraestrutura atual
- Adicionar apenas funcionalidades realmente novas
- Integrar com servi√ßos existentes

#### **Entregas:**

```
‚úÖ Entidades m√≠nimas necess√°rias:
   - HolidayClassificationEntity (nova)
   - OperationalGoalsParametersEntity (nova)
   - OperationalGoalsCalculationEntity (nova)

‚úÖ Extens√£o de servi√ßos existentes:
   - ParameterService.saveOperationalGoalsMetas() (m√©todo novo)
   - CompetitionPeriodService.onPeriodCreated() (hook novo)

‚úÖ Novos servi√ßos espec√≠ficos:
   - HolidayManagementService
   - OperationalGoalsCalculationService
   - OperationalGoalsParametersService
   - OperationalGoalsOracleService (extende OracleEtlService)

‚úÖ Integra√ß√£o com Brasil API (feriados)

‚úÖ Mapeamento real por nome de setores

‚úÖ Query Oracle espec√≠fica para KM e combust√≠vel

‚úÖ Migra√ß√µes de banco de dados

‚úÖ Testes unit√°rios dos servi√ßos novos
```

#### **Crit√©rios de Aceite:**

- ‚úÖ Detec√ß√£o autom√°tica de feriados funcional
- ‚úÖ Mapeamento de setores Oracle‚ÜíApp funcional
- ‚úÖ Query Oracle retornando dados hist√≥ricos
- ‚úÖ Par√¢metros configur√°veis salvando corretamente

### **üî• Sprint 2: Algoritmos de C√°lculo (Semanas 3-4)**

#### **Objetivos:**

- Implementar l√≥gica espec√≠fica de c√°lculo
- Usar dados das Raw Entities existentes
- Integrar com PerformanceDataEntity atual

#### **Entregas:**

```
‚úÖ Algoritmos implementados:
   - calculateKmPrevista() - com classifica√ß√£o de feriados
   - calculateCombustivel() - usando RawOracleFleetPerformanceEntity
   - calculatePneusPecas() - usando PerformanceDataEntity
   - Sistema de Saldo - usando ParameterValueEntity existente

‚úÖ Integra√ß√£o com dados existentes:
   - Aproveitamento de Raw Entities para hist√≥rico
   - Uso de PerformanceDataEntity para custos
   - Consulta de ParameterValueEntity para metas anteriores

‚úÖ Valida√ß√µes de neg√≥cio:
   - Per√≠odo deve estar em PLANEJAMENTO
   - Feriados devem estar classificados
   - Dados hist√≥ricos devem estar dispon√≠veis

‚úÖ Testes com dados reais da aplica√ß√£o

‚úÖ Logs detalhados e auditoria
```

#### **Crit√©rios de Aceite:**

- ‚úÖ C√°lculo completo executado sem erros
- ‚úÖ Resultados conferem com metodologia documentada
- ‚úÖ Sistema de saldo funcionando corretamente
- ‚úÖ Integra√ß√£o com dados existentes validada

### **üîó Sprint 3: APIs e Integra√ß√£o Final (Semana 5)**

#### **Objetivos:**

- Criar endpoints REST
- Integrar com sistema de servi√ßos existente
- Finalizar fluxo de aprova√ß√£o

#### **Entregas:**

```
‚úÖ APIs REST completas:
   - /operational-goals/periods/:id/holidays-status
   - /operational-goals/periods/:id/classify-holidays
   - /operational-goals/periods/:id/calculate
   - /operational-goals/calculations/:id/approve
   - /operational-goals/parameters (GET/PUT)

‚úÖ Integra√ß√£o com plugins existentes:
   - Adi√ß√£o aos services.ts existente
   - Uso do sistema de autentica√ß√£o atual
   - Aproveitamento de middleware existente

‚úÖ Salvamento em ParameterValueEntity:
   - Metas salvas no mesmo local das outras
   - Sistema de ranking continua funcionando
   - Auditoria usando AuditLogService existente

‚úÖ Valida√ß√µes e autoriza√ß√µes:
   - Apenas diretores podem calcular/aprovar
   - Valida√ß√£o de entrada de dados
   - Tratamento de erros padronizado

‚úÖ Documenta√ß√£o Swagger atualizada
```

#### **Crit√©rios de Aceite:**

- ‚úÖ Todas as APIs funcionando via Postman
- ‚úÖ Metas salvas no sistema existente
- ‚úÖ Per√≠odo pode ser ativado ap√≥s aprova√ß√£o
- ‚úÖ Sistema de ranking considera novas metas

### **üé® Sprint 4: Interface Gerencial (Semana 6)**

#### **Objetivos:**

- Integrar com interface existente de per√≠odos
- Criar tela de configura√ß√£o de par√¢metros
- Implementar UX de aprova√ß√£o

#### **Entregas:**

```
‚úÖ Integra√ß√£o com tela de per√≠odos existente:
   - HolidayClassificationSection
   - OperationalGoalsCalculationSection
   - Exclus√£o dos 3 crit√©rios autom√°ticos das outras metas

‚úÖ Tela de configura√ß√£o de par√¢metros:
   - Interface para diretores
   - Valida√ß√µes e justificativas obrigat√≥rias
   - Hist√≥rico de altera√ß√µes
   - Auditoria completa

‚úÖ Componentes de interface:
   - CalculationResultsDisplay
   - ParameterCard com edi√ß√£o inline
   - HolidayClassificationItem
   - ValidationSummary

‚úÖ Estados de loading e feedback:
   - Indicadores de progresso
   - Mensagens de erro/sucesso
   - Valida√ß√µes em tempo real

‚úÖ Integra√ß√£o com APIs:
   - Hooks customizados para APIs
   - Cache de dados
   - Refresh autom√°tico

‚úÖ Design responsivo e acess√≠vel:
   - Mobile-first
   - Contraste adequado
   - Navega√ß√£o por teclado
```

#### **Crit√©rios de Aceite:**

- ‚úÖ Fluxo completo funcionando na interface
- ‚úÖ Diretor consegue classificar feriados intuitivamente
- ‚úÖ Resultados de c√°lculo s√£o claros e detalhados
- ‚úÖ Configura√ß√£o de par√¢metros √© simples e segura

### **üöÄ Sprint 5: Homologa√ß√£o e Deploy (Semana 7)**

#### **Objetivos:**

- Testes em ambiente de produ√ß√£o
- Valida√ß√£o com usu√°rios reais
- Deploy seguro

#### **Entregas:**

```
‚úÖ Ambiente de homologa√ß√£o:
   - Deploy completo da funcionalidade
   - Dados de teste realistas
   - Valida√ß√£o com planilhas Excel atuais

‚úÖ Testes de aceita√ß√£o:
   - Diretor testa fluxo completo
   - Compara√ß√£o com c√°lculos manuais
   - Valida√ß√£o de performance

‚úÖ Documenta√ß√£o final:
   - Manual do usu√°rio para diretores
   - Guia de troubleshooting
   - Documenta√ß√£o t√©cnica para manuten√ß√£o

‚úÖ Treinamento:
   - Sess√£o com diretores
   - Walkthrough da interface
   - Q&A sobre metodologia

‚úÖ Deploy de produ√ß√£o:
   - Migra√ß√£o de banco validada
   - Monitoramento ativo
   - Rollback plan testado

‚úÖ Primeiro per√≠odo real:
   - C√°lculo real para pr√≥ximo per√≠odo
   - Acompanhamento de resultados
   - Feedback dos usu√°rios
```

#### **Crit√©rios de Aceite:**

- ‚úÖ Sistema funcionando em produ√ß√£o sem erros
- ‚úÖ Primeiro per√≠odo calculado com sucesso
- ‚úÖ Usu√°rios confiantes e satisfeitos
- ‚úÖ Performance adequada

---

### **8.1 Timeline Visual do Projeto**

```mermaid
gantt
    title Implementa√ß√£o Sistema de Metas Operacionais
    dateFormat  YYYY-MM-DD
    section Sprint 1: Funda√ß√£o
    Entidades e Migra√ß√µes     :done, s1-1, 2025-07-21, 3d
    Servi√ßos Base            :done, s1-2, 2025-07-24, 4d
    Integra√ß√£o Oracle        :done, s1-3, 2025-07-28, 3d
    Testes Unit√°rios         :done, s1-4, 2025-07-31, 2d

    section Sprint 2: Algoritmos
    KM Prevista              :active, s2-1, 2025-08-04, 3d
    Combust√≠vel              :s2-2, 2025-08-07, 3d
    Pneus/Pe√ßas + Saldo      :s2-3, 2025-08-11, 4d
    Testes Integra√ß√£o        :s2-4, 2025-08-15, 2d

    section Sprint 3: APIs
    Endpoints REST           :s3-1, 2025-08-18, 3d
    Integra√ß√£o Servi√ßos      :s3-2, 2025-08-21, 2d
    Valida√ß√µes/Auth          :s3-3, 2025-08-23, 2d
    Documenta√ß√£o Swagger     :s3-4, 2025-08-25, 1d

    section Sprint 4: Interface
    Tela Classifica√ß√£o       :s4-1, 2025-08-25, 3d
    Tela C√°lculo/Aprova√ß√£o   :s4-2, 2025-08-28, 3d
    Tela Par√¢metros          :s4-3, 2025-09-01, 2d
    Testes E2E               :s4-4, 2025-09-03, 2d

    section Sprint 5: Deploy
    Homologa√ß√£o              :s5-1, 2025-09-08, 3d
    Treinamento              :s5-2, 2025-09-11, 2d
    Deploy Produ√ß√£o          :s5-3, 2025-09-13, 2d
    Primeiro Per√≠odo Real    :milestone, 2025-09-15, 0d
```

## **üìã RESUMO DAS CORRE√á√ïES APLICADAS**

### **‚úÖ Problemas Corrigidos:**

1. **Campo erpId:** Removido e substitu√≠do por mapeamento por nome
2. **Entidades duplicadas:** Minimizadas para apenas 3 novas entidades
3. **ETL Oracle:** Aproveitado servi√ßo existente ao inv√©s de criar novo
4. **ParameterValueEntity:** Usado para metas, criado OperationalGoalsParametersEntity apenas para configura√ß√£o
5. **Raw Entities:** Aproveitadas as existentes ao inv√©s de criar novas
6. **Servi√ßos:** Estendidos ao inv√©s de duplicados

### **‚úÖ Arquitetura Final:**

- **3 entidades novas** (m√≠nimo necess√°rio)
- **4 servi√ßos novos** (especializados)
- **Extens√£o de 2 servi√ßos existentes** (ParameterService, CompetitionPeriodService)
- **Aproveitamento total** da infraestrutura Oracle/MySQL existente
- **Integra√ß√£o completa** com sistema de vig√™ncias atual
- **Compatibilidade 100%** com sistema de ranking existente

### **üéØ Benef√≠cios da Arquitetura Corrigida:**

1. **Aproveitamento m√°ximo** da infraestrutura robusta existente
2. **Risco m√≠nimo** de conflitos com funcionalidades atuais
3. **Implementa√ß√£o mais r√°pida** por usar c√≥digo j√° testado
4. **Manuten√ß√£o simplificada** por seguir padr√µes existentes
5. **Escalabilidade** aproveitando arquitetura madura

---

**üìä Esta documenta√ß√£o corrigida reflete a realidade da API e prop√µe uma implementa√ß√£o que aproveita ao m√°ximo a infraestrutura existente, minimizando riscos e maximizando a reutiliza√ß√£o de c√≥digo j√° testado e funcional.**
